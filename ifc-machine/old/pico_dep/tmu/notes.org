A place for comments that are too large.

* [genJoin] and [genFlows] specs

(* NC: [genJoin] and [genFlows] need specs relating them to [flows]
and [join] from the [JoinSemiLattice] class.  For [genJoin], the spec
would be something like: if the

  stack = n1 : n2 : s ,

and [ni = labToZ li], then after running [genJoin] have

  stack = labToZ (join l1 l2) : s .

DD: Yes, we need all of these.
    Need to add a [eval] relation to the concrete lattices??
    Can we cope with this kind of dependencies in the current setting?

Now, if [flows] is defined in terms of [join], then we can implement
[genFlows] in terms of [genJoin], which should make it easier to
establish that [genFlows] meets its spec.

Looking at [JoinSemiLattice] in ../lib/Lattices.v I see that [join]
and [flows] are independent parameters.  Why not define [flows] in
terms of [join]? I.e.

  flows l1 l2 := (join l1 l2 = l2) .

I guess this is propositional and the current [flows] returns
[bool]. But it's easy to fix, just add an [eqDec] param to the class:

  eqDec : forall (l1 l2 : Lab), {l1 = l2} + {l1 <> l2} ,

and define a bool version using that.  There is already a [bot_dec]
specialized to [bot], and the [flows_join] axiom already requires that

  flows l1 l2 := "prop to bool" (join l1 l2 = l2)

is a valid def of [flows].  

DD: This is an option. Now, I'm not sure it would lead to 
   a efficient version of flows, the day we'll want to extract
   and run the code on say, a particular Lattice.
   (this is all prospective, but we might want to be able to
   talk with QC guys...)

Why have a bunch of extra class params relating [flows] and [join]
which are actually lemmas?

DD: the smaller the typeclass, the better (I agree it's not minimal right now, though :-))
    as indicated in Lattices.v, this simplification pass must be done at some point.    
    
*)

* discussion of need for uniform rule generation
(* NC: I don't see how the use of [bot]s here for the operand labels
   is justified in the correctness conjecture below.  We can pass
   [bot]s here because the [fetch_rule_impl] we have in mind,
   [TMURule.fetch_rule], generates a rule that is uniform in the
   operand labels.  But, this uniformity constraint is not enforced
   anywhere, so the current abstract proof should be impossible.

   The easy way to formalize the uniformity constraint is to change
   the type of [fetch_rule_impl] to take an op name and return an
   [AllowModify].  Then we change the conjecture to evaluate the
   [AllowModify] in terms of a context that *we* (the fault handler)
   create, based on the memory.  The fact that we are allowed to
   create a context this way, from memory, *defines* the label passing
   interface between the CPU and the TMU concrete ware.

   DD: Hmm... I think I agree. I don't know if we could completely get
   rid of that handler_initial_mem_matches, as this would basically be
   the spec of the function make_label_context. Maybe I miss something.

     NC: What I'm proposing is to make [make_label_context] *be* the
     spec of the interface, and so it would not have a spec itself.

     The point is that in the generated code we read the label values
     from memory (using [genVar]).  Meanwhile, [make_label_context]
     reads those same label values from memory to construct the
     context [eval_var]. The context is used in the [handler_correct]
     expression

       match apply_rule eval_var am with ...

     to connect the abstract [fetch_rule_impl] to our concrete
     implementation.

     The fact that those (operand and pc) label values we read from
     memory were written there by [check_tags] would not be captured
     in the conjecture, but I don't think it's captured now either
     ... but maybe making that connection explicit would bring back a
     [handler_initial_mem_matches] like spec?

   Changes we have to make:

   + replace [OpLabel] type with a much simpler [InstrOp] type, which
     only includes the op names (can't just use [Instr] here because
     some instrs, e.g. [Push], take arguments.  Or we could even just
     use numbers, since [check_tags] already does that via [mvector].
     
     DD: OpLabels are used at the abstract level, and that would be
     nice to keep InstrOp, and not numbers.

       NC: I'm proposing to not use the [OpLabel] at the abstract
       level either!

       But, I would not be surprised if I have not thought about it
       enough; I certainly don't understand how they are supposed to
       play into the proofs.  But, I expect they don't help much,
       since their type doesn't prevent you from constructing them in
       the wrong way.  E.g., nothing stops me from accidentally
       writing

         <| rl,rpcl |> <- run_tmr  (OpLabelStore pcl addrl xl ml);

       instead of

         <| rl,rpcl |> <- run_tmr  (OpLabelStore addrl xl ml pcl);

       in [cstep].  So, I expect it's just as good to write, e.g.,

         <| rl,rpcl |> <- run_tmr StoreOp (addrl, xl, ml, pcl);

       instead.


       For the cases with fewer than four args we have to write some
       extra [bot]s.  E.g.

         [_,rpcl] <- check_tags (OpLabelNoop pcl)

       becomes

         [_,rpcl] <- check_tags NoopOp (bot, bot, bot, pcl)

       but this is not the end of the world.


       Concretely, here is how I imagine replacing the current uses of
       [OpLabel]:

       - [mvector]: currently have:

           Definition mvector (oplab: @OpLabel T) :
            Z * Z * Z * Z * Z :=
             let '(l1,l2,l3,lPC) :=
               match oplab with
                 | OpLabelNoop pc => (bot,bot,bot,pc)
                 | OpLabelAdd op1 op2 pc => (op1,op2,bot,pc)
                 | OpLabelSub op1 op2 pc => (op1,op2,bot,pc)
                 | OpLabelPush op pc => (op,bot,bot,pc)
                 | OpLabelLoad loc data pc => (loc,data,bot,pc)
                 | OpLabelStore loc new_data old_data pc =>
                     (loc,new_data,old_data,pc)
                 | OpLabelJump jmp pc => (jmp,bot,bot,pc)
                 | OpLabelBranchNZ op pc => (op,bot,bot,pc)
                 | OpLabelCall call pc => (call,bot,bot,pc)
                 | OpLabelRet pcl pc => (pcl,bot,bot,pc)
                 | OpLabelVRet data pcl pc => (data,pcl,bot,pc)
                end in
             (oplabToZ oplab, labToZ l1, labToZ l2, labToZ l3, labToZ lPC).

         Replace with (this is dumb ...):

           Definition mvector (op : InstrOp) (ls : list Label) (lPC : Label) :
            Z * Z * Z * Z * Z :=
             let '(l1,l2,l3) :=
               match ls with
               | nil => (bot,bot,bot)
               | l1 :: ls1 =>
                 match ls1 with
                 | nil => (l1,bot,bot)
                 | l2 :: ls2 =>
                   match ls2 with
                   | nil     => (l1,l2,bot)
                   | l3 :: _ => (l1,l2,l3)
                   end
                 end
               end in
             (instrOpToZ op, labToZ l1, labToZ l2, labToZ l3, labToZ lPC).

         But now that I wrote that, I see it's ugly and I think your
         suggestion below to use tuples is much much better.  Then we
         get

           mvector (op : InstrOp) (ls : Label^4) :
            Z * Z * Z * Z * Z :=
             let '(l1,l2,l3,lPC) := ls in
             (instrOpToZ op, labToZ l1, labToZ l2, labToZ l3, labToZ lPC).

       - [check_tags]: currently have:

           Definition check_tags (oplab: @OpLabel T) :
             @CMach T (option (T * T)) := ...

         Replace with:

           check_tags (op: InstrOp) (ls : Label^4) :
             @CMach T (option (T * T)) := ...

         And similar for any other function that currently takes an
         [OpLab] and pushes it down.

       - [fetch_rule]: currently have:

           fetch_rule (oplab:OpLabel) : (AllowModify * (LAB -> option T))

         Replace with:

           fetch_rule (op : InstrOp) : AllowModify

         and factor out all the stuff about contexts. Maybe:

           make_context (ls : Label^4) : ([LAB -> option T)])

         The key is that now [fetch_rule] just fetches the rule, so
         its type enforces the uniformity of rules (independent of
         label values) that we need for the correctness proof.

       - [run_tmr]: Replace:

           Fixpoint run_tmr (oplab: OpLabel) :  @AMach T (option T * T) :=
             let (r,eval_var) := fetch_rule oplab in  
             match apply_rule eval_var r with
               | None => error_          
               | Some rv => ret rv                    
             end.            

         with:

           Fixpoint run_tmr (op: InstrOp) (ls: Label^4): @AMach T (option T * T) :=
             let r := fetch_rule op in
             let eval_var := make_context ls in  
             match apply_rule eval_var r with
               | None => error_
               | Some rv => ret rv          
             end.

   + make [fault_handler] use [InstrOp] and the new [fetch_rule_impl].

   + change the [handler_correct] conjecture to compute the instr op
     and label context from memory.  I.e., replace the forall bound
     [oplab] with a computed value using [index_list_Z addrOpLabel]
     (and why are mem addrs allowed to be negative ???), and then
     replace the line

       let (am,eval_var) := fetch_rule_impl oplab in

     with something like

       let am       := fetch_rule_impl instrOp in
       let eval_var := make_label_context m0 in

     where [make_label_context] computes the label context
     corresponding to the initial memory [m0].

   + delete [handler_initial_mem_matches], or at least greatly
     simplify it, since the initial mem now matches by definition of
     the label passing interface!

     Does this somehow create some difficulty connecting the full
     implementation in TMUConcrete.v to the abstract machine?  I don't
     see how, since right now there is no connection between the
     [OpLabel] value in the conjecture and the one passed to
     [check_tags] in [cstep].  We can change
     [handler_initial_mem_matches] to check that some [InstrOp]
     argument matches memory if we like, since that's the analog of
     the current [OpLabel] arg and the [handler_initial_mem_matches]
     check.

   Bonus changes: we can now also simplify TMUConcrete.v as follows:

   + change check_tags to take two arguments: the [InstrOp] (or
     number), the pc label, and a list of op arguments:

       check_tags : InstrOp -> Label -> [Label] -> (maybe the result tags)

     Now [mvector] is no longer used, since the only use for [mvector]
     was to unpack an [OpLabel] which had *just* been created as an
     argument in the call to [check_tags].  Or, at least, [mvector] is
     greatly simplified: it converts the [InstrOp] to a number (if we
     don't just use numbers outright, and why not?), and then [bot]
     extends the operand label list until it has length three ([mvector]
     already did this).

     DD: Hmm... Is it a real gain? I'm afraid that using lists of size
     > 3 may complicate the semantics... If not a list, then a triple?

       NC: you're right, tuples are much better.  And then we might as
       well just use a quad, e.g.

         (l1,l2,l3,lPC),

       instead of breaking out the pc label as a separate argument.

   + redefine [fetch_rule] to just take the [InstrOp] as argument, and
     only return [AllowModify]. This mostly involves deleting have of
     the current [fetch_rule], namely all the label context
     definitions.

*)
