
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Metavariable conventions

metavar o {{tex \mathord{\circ} }} ::=           {{com binary ops}}

metavar M {{tex \mu }} ::=      {{com memory}}

metavar I {{tex \iota }} ::=      {{com instruction memory}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

n, m, k, p, npc {{tex n_\mathit{pc} }} :: 'n_' ::= {{com Integers}}
  | 0                       :: :: Zzro
  | 1                       :: :: Zone
  | n1 + n2                 :: :: ZPlus
  | n1 o n2                 :: :: ZBinOp
  | ( n )                   :: S :: ZParen

L, K, Lpc {{tex L_\mathit{pc} }} :: 'L_' ::=   {{com Labels}}
  | bot                     :: :: Lbot      {{com bottom label}}
  | labOf a                 :: :: Labelof    {{com extract label of an atom}}
  | L1 \/ L2                :: :: Ljoin     {{com label join}}
  | ( L )                   :: S :: LParen

oL, l {{tex \ell }}  :: 'oL_' ::=   {{com Optional Labels}}
  | _                     :: :: Nothing {{tex \_}}
  | L                     :: :: SomeLabel

a, b, pc :: 'a_' ::=                       {{com Atoms}}
  | n @ L                   :: :: ValAtom {{com atom = integers value plus label}}
  | a \/ L                  :: :: Ajoin   {{com join [[L]] with atom's label}}
  | a + 1                   :: :: ANext   {{com increment offset part of code pointer }}
  | ( a )                   :: S :: AParen

instr :: 'instr_' ::=                              {{com Instructions}}
  | Nop                     :: :: iNop
  | Push n                  :: :: iPush    {{com push constant integer}}
  | Pop                     :: :: iPop
  | Dup                     :: :: iDup
  | BinOp o                 :: :: iBinOp   {{com binary op, returning integer}}
  | Jump                    :: :: iJump
  | Bnz n                   :: :: iBnz     {{com conditional relative jump}}
  | Call                    :: :: iBCall
  | Ret                     :: :: iBRet
  | Load                    :: :: iLoad    
  | Store                   :: :: iStore
  | Output                  :: :: iOutput  {{com output the top of the stack, tainted with pc}}
  | Halt                    :: :: iHalt

opcode :: 'opcode_' ::=                              {{com Opcodes}}
  | nop                     :: :: oNop
  | push                    :: :: oPush    {{com push constant integer}}
  | pop                     :: :: oPop
  | dup                     :: :: oDup
  | binop                   :: :: oBinOp   {{com binary op, returning integer}}
  | jump                    :: :: oJump
  | bnz                     :: :: oBNZ     {{com conditional relative jump}}
  | call                    :: :: oBCall
  | ret                     :: :: oBRet
  | load                    :: :: oLoad    
  | store                   :: :: oStore
  | output                  :: :: oOutput  {{com output the top of the stack, tainted with pc}}
  | halt                    :: :: oHalt

e :: 'e_' ::=                              {{com Events}}
  | epsilon                 :: :: epsilon {{com no event }}
  | n @ L                  :: :: intE  {{com observable value event }}
  | ( e )                   :: S :: eParen   

S {{tex \sigma }} :: 'S_' ::=                     {{com Stack}}
  | Smty                    :: :: Smty     {{com empty stack}}
  | a ; S                   :: :: Sdcons   {{com stack atom cons}}
  | pc ;; S         :: :: Srcons   {{com stack frame marker cons (with
                                         return pc and protecting label)}}
  % | S1 $ S2                 :: ::   Sappend  {{com stack append}}
  | [ S ]                   :: :: SParen
  % | [ a1 .. aj ]            :: :: SElems

LE, exprr {{tex expr_{res} }}, exprpc {{tex expr_{pc} }}  :: 'LE_' ::= {{com Label Expressions}}
  | LAB1 :: :: eLab1 {{tex \mathsf{LAB}_1}}
  | LAB2 :: :: eLab2 {{tex \mathsf{LAB}_2}}
  | LAB3 :: :: eLab3 {{tex \mathsf{LAB}_3}}
  | LABPC :: :: eLabPC {{tex \mathsf{LAB}_\mathit{pc} }}
  | JOIN LE1 LE2 :: :: eJoin
  | __ :: :: DontCare
  | ( LE ) :: S :: eParen

BE, allow :: 'BE_' ::= {{com Boolean Expressions over Labels}}
  | TRUE :: :: bTrue
  | FLOWS LE1 LE2 :: :: bFlows
  | AND BE1 BE2 :: :: bAnd
  | OR BE1 BE2 :: :: bOr
  | ( BE ) :: S :: bParen

RHS :: 'RHS' ::= {{com Right hand side of rules }}
  | << BE , LE1 , LE2 >> :: :: RightHandSide {{com Allow part, Result Label, Next PC label }}
  {{tex \langle [[BE]], [[LE1]], [[LE2]] \rangle }}
% alternative: \guillemotleft ... \guillemotright

formula :: formula_ ::=  
 | judgement                :: :: judgement
 | I ( pc ) = instr         :: :: instr_lookup  {{com instruction lookup (fails if pc not a code pointer)}}
 % | P fresh                  :: :: Pfreshfor     {{com [[P]] is fresh for the current machine state}}
 % | fp fresh                 :: :: fpfreshfor     {{com [[fp]] is fresh for the current machine state}}
 | read M p = a             :: :: load          {{com read from data memory }}
 | store M p a = M'         :: :: store         {{com memory store of atom }}

 | flowsTo L1 L2 = n        :: :: flowsto       {{com binop operation on labels - return int  }}
 | n1 <> n2                 :: :: not_eq_int
 | n1 = n2                  :: :: eq_int
 | M1 = M2                  :: :: eq_mem
 | p1 <> p2                 :: :: not_eq_pntr
 | p1 = p2                  :: :: eq_pntr
 | a1 = a2                  :: :: eq_atm
 | L1 <= L2                 :: :: labelLeq
 | L1 = L2                  :: :: labelEq
 | RHS1 = RHS2              :: :: rhs_eq

 % | v1 = .. = vj = v         :: :: vals_eq
 % | formula1 ==> formula2    :: :: implication
 | formula1 quad formula2   :: :: savingspace

terminals :: 'terminals_' ::=
  | ==>                 :: :: eval       {{tex \Longrightarrow }}
  | quad                :: :: savespace  {{tex \qquad }}
  | \/                  :: :: join       {{tex \mathord{\vee} }}
  | |_|                 :: :: ljoin      {{tex \mathord{\sqcup} }}
  | <>                  :: :: noteq      {{tex \neq }}
  | @                   :: :: atlabel    {{tex \mathord{@} }}
  | ;;                  :: :: semisemi   {{tex \mathord{;\!;} }}
  | +                   :: :: plus       {{tex \mathord{+} }}
  % | <<                  :: :: lbrack       {{tex \llbracket }}
  % | >>                  :: :: rbeack       {{tex \rrbracket }}
  | +1                  :: :: plusplus   {{tex {\scriptstyle \mathord{+\!+} } }}
  | |->                 :: :: mapsto     {{tex {\scriptstyle \mathord{\mapsto} } }}
  | forall              :: :: forall     {{tex \forall }}
  | <=                  :: :: le         {{tex \le }}
  | Smty                :: :: Smty       {{tex \text{\sf mty} }}
  | bot                 :: :: bot        {{tex \bot }}
  | <|                  :: :: lcp        {{tex \langle }}
  | |>                  :: :: rcp        {{tex \rangle }}

  | Call                :: :: Call      {{tex \text{\sf Call} }} 
  | Output              :: :: Output  {{tex \text{\sf Output} }}
  | Load                :: :: Load       {{tex \text{\sf Load} }} 
  | Store               :: :: Store      {{tex \text{\sf Store} }} 
  | Nop                 :: :: Nop        {{tex \text{\sf Nop} }}
  | Push                :: :: Push       {{tex \text{\sf Push} }} 
  | Pop                 :: :: Pop        {{tex \text{\sf Pop} }} 
  | Dup                 :: :: Dup        {{tex \text{\sf Dup} }} 
  | BinOp               :: :: BinOp      {{tex \text{\sf BinOp} }}
  | Jump                :: :: Jump       {{tex \text{\sf Jump} }} 
  | Bnz                 :: :: Bnz        {{tex \text{\sf Bnz} }} 
  | Ret                 :: :: Ret        {{tex \text{\sf Ret} }} 
  | Halt                :: :: Halt       {{tex \text{\sf Halt} }} 

  | epsilon             :: :: eE0       {{tex \varepsilon }} 


defns
AbstractHighLevelSmallStep :: '' ::=

  defn 
  M1 , I1 , S1 , pc1 -- e -> M2 , I2 , S2 , pc2  :: :: step :: '' 
  {{tex [[M1]], [[S1]], [[pc1]] \xrightarrow{[[e]]} [[M2]], [[S2]], [[pc2]] }} by

     I(pc) = Nop
     ------------------------------------- :: Step_Nop
     M, I, S, pc -- epsilon -> M, I, S, pc+1

     I(pc) = Output
     -------------------------------------------------------- :: Step_Output
     M, I, [n@K; S], pc -- n @ K\/labOf(pc) -> M, I, S, pc+1

    % pointer offsetting won't be a binop, now stricter on the input values
    % they must be integers
     I(pc) = BinOp o
    -------------------------------------------------------- :: Step_BinOp
     M, I, [n1@L1; n1@L2; S], pc -- epsilon -> M, I, [(n1 o n2)@(L1\/L2); S], pc+1

     I(pc) = Push n
     -------------------------------------------------------- :: Step_Push
     M, I, S, pc -- epsilon -> M, I, [n @ bot; S], pc+1

     I(pc) = Load   quad    read M p = a
     -------------------------------------------------------- :: Step_Load
     M, I, [p@K; S], pc -- epsilon -> M, I, [a \/ K; S], pc+1

     I(pc) = Store    quad    read M p = n@L
     K \/ labOf(pc) <= L   quad   store M p (a \/ K \/ labOf(pc)) = M'
     -------------------------------------------------------- :: Step_Store
     M, I, [p@K; a; S], pc -- epsilon -> M', I, S, pc+1

     I(pc) = Jump
      -------------------------------------------------------- :: Step_Jump
     M, I, [pc'; S], pc -- epsilon -> M, I, S, pc' \/ labOf(pc)
    
     I(pc) = Bnz k  quad   m <> 0 
     -------------------------------------------------------- :: Step_Bnz_Yes
     M, I, [m@K; S], n@L -- epsilon -> M, I, S, (n+k)@L\/K
    
     I(pc) = Bnz k quad   m = 0 
     -------------------------------------------------------- :: Step_Bnz_No
     M, I, [m@K; S], n@L -- epsilon -> M, I, S, (n+1)@L\/ K

     I(pc) = Call
     -------------------------------------------------------- :: Step_Call
     M, I, [ pc' ; a ; S], pc -- epsilon -> M, I, [a; pc+1 ;; S], pc'\/labOf(pc)

     I(pc) = Ret
     -------------------------------------------------------- :: Step_Ret
     M, I, [a ; pc' ;; S], pc -- epsilon -> M, I, [a\/labOf(pc) ; S], pc'

     % I(pc) = Pop
     % -------------------------------------------------------- :: Step_Pop
     % M, I, [a; S], pc -- espilon -> M, I, S, pc+1

     % I(pc) = Swap
     % -------------------------------------------------------- :: Step_Swap
     % M, I, [a1; a2; S], pc -- espilon -> M, I, [a2; a1; S], pc+1

     % I(pc) = Ret
     % -------------------------------------------------------- :: Step_Ret_Pop
     % M, I, [a; a'; S], pc --epsilon -> M, I, [a; S], pc

     % M(pc) = Dup
     % -------------------------------------------------------- :: Step_Dup
     % M, [a; S], pc, T --> M, [a;a;S], pc+1, T



%%******* NEW RELATIONS FOR EXPLICIT RULES

    %  I(pc) = BinOp o   
    %  Binop, (L, L1, L2, _) |- rL, rpcl
    % -------------------------------------------------------- :: Step_BinOp
    %  M, I, [n1@L1; n1@L2; S], n@L -- epsilon -> M, I, [(n1 o n2)@rl; S], (n+1@rpcl)

    %  For irrelevant result labels 
    %  Binop, (L, L1, L2, _) |- _, rpcl
     
    % ------------------------------------- :: Rule_Binop
    % Binop |- TRUE, JOIN LAB1 LAB2, LABPC

    % I |- A, E1, E2
    % evalb rho A 
    % evall rho E1 l1  quad   evall rho E2 l2
    % ------------------------------------- :: eval
    % I , rho |- l1, l2

defns 
  RuleEvaluation :: '' ::= 

  defn 
  l1 , l2 , l3 , l4 |- allow :: :: eval_cond :: ''
  {{tex [[l1]] , [[l2]] , [[l3]] , [[l4]]
        \vdash  [[allow]] }}
  by

  defn 
  l1 , l2 , l3 , l4 |-- LE oL  :: :: eval_expr :: ''
  {{tex [[l1]] , [[l2]] , [[l3]] , [[l4]]
        \vdash  [[LE]] \downarrow [[oL]]}}
  by

  defn 
  l1 , l2 , l3 , l4 ~~ opcode ~> L , oL'  :: :: run_tmr :: '' 
  {{tex [[l1]] , [[l2]] , [[l3]] , [[l4]]
%        \overset{[[opcode]]}{\leadsto}
        \leadsto_{[[opcode]]}
        [[L]] , [[oL']] }}
  by
  
     Rule(opcode) = << allow, exprpc, exprr >>  quad  l1, l2, l3, l4 |- allow
     l1, l2, l3, l4 |--  exprpc Lpc'      quad   l1, l2, l3, l4 |--  exprr K
   -------------------------------------- :: eval_rule
     l1, l2, l3, l4 ~~ opcode ~> Lpc', K


defns
AbstractExplicitSmallStep :: '' ::=


  defn
  M1 , S1 , pc1 -- e -> M2 , S2 , pc2  :: :: step_exp :: '' 
  {{tex [[M1]], [[S1]], [[pc1]] \xrightarrow{[[e]]} [[M2]], [[S2]], [[pc2]] }} by

     I(pc) = Nop
     Lpc, _, _, _ ~~ nop ~> Lpc', _
     -------------------------------------- :: Nop
     M, S, npc@Lpc -- epsilon -> M, S, (npc+1)@Lpc'

     I(pc) = Output
     Lpc, L1, _, _ ~~ output ~> Lpc', L'
     -------------------------------------------------------- :: Output
     M, [n@L1; S], npc@Lpc -- n@L' -> M, S, (npc+1)@Lpc'

     I(pc) = BinOp o
     Lpc, L1, L2, _ ~~ binop ~> Lpc', L
    -------------------------------------------------------- :: BinOp
     M, [n1@L1; n1@L2; S], npc@Lpc -- epsilon -> M, [(n1 o n2)@L'; S], (npc+1)@Lpc'

     I(pc) = Push n
     Lpc, _, _, _ ~~ push ~> Lpc', L'
     -------------------------------------------------------- :: Push
     M, S, npc@Lpc -- epsilon -> M, [n@L'; S], (npc+1)@Lpc'

     I(pc) = Load   quad    read M p = n@L2
     Lpc, L1, L2, _ ~~ load ~> Lpc', L'
     -------------------------------------------------------- :: Load
     M, [p@L1; S], pc -- epsilon -> M, [n@L'; S], (npc+1)@Lpc'

     I(pc) = Store    quad    read M p = n@L3
     Lpc, L1, L2, L3 ~~ store ~> Lpc', L'
     store M p m@L' = M'
     -------------------------------------------------------- :: Store
     M, [p@L1; m@L2; S], npc@Lpc -- epsilon -> M', S, (npc+1)@Lpc'

     I(pc) = Jump
     Lpc, L1, _, _ ~~ jump ~> Lpc', _
      ------------------------------------------------------- :: Jump
     M, [n@L1; S], npc@Lpc -- epsilon -> M, S, n@Lpc'
    
     I(pc) = Bnz k  quad   m <> 0 
     Lpc, L1, _, _ ~~ bnz ~> Lpc', _
     -------------------------------------------------------- :: Bnz_Yes
     M, [m@L1; S], npc@Lpc -- epsilon -> M, S, (npc+k)@Lpc
    
     I(pc) = Bnz k quad   m = 0
     Lpc, L1, _, _ ~~ bnz ~> Lpc', _
     -------------------------------------------------------- :: Bnz_No
     M, [m@L1; S], npc@Lpc -- epsilon -> M, S, (npc+1)@Lpc

     % CH: This is not at all in sync with the Coq code
     % CH: "a" could be expanded out, its label passed into the TMU
     %         and returned out as a 3rd(!?) argument? Ouch!
     I(pc) = Call
     Lpc, L1, _, _ ~~ call ~> Lpc', L'
     -------------------------------------------------------- :: Call
     M, [ n@L1 ; a ; S], npc@Lpc -- epsilon -> M, [a; (npc+1)@L' ;; S], n@Lpc'

     % CH: This corresponds to VRet in the Coq code
     I(pc) = Ret
     Lpc, L1, L2, _ ~~ ret ~> Lpc', L'
     -------------------------------------------------------- :: Ret
     M, [n@L1 ; m@L2 ;; S], npc@Lpc -- epsilon -> M, [n@L' ; S], m@Lpc'

funs
      Rule ::=
    fun
      Rule ( opcode ) :: RHS :: rule
    by
Rule(nop)    === << TRUE, LABPC, __ >>
Rule(output) === << TRUE, LABPC, JOIN LAB1 LABPC >>
Rule(binop)  === << TRUE, LABPC, JOIN LAB1 LAB2 >>
Rule(push)   === << TRUE, LABPC, LAB1 >>
Rule(load)   === << TRUE, LABPC, JOIN LAB1 LAB2 >>
Rule(store)  === << FLOWS (JOIN LAB1 LABPC) LAB3, LABPC, JOIN LAB1 (JOIN LAB2 LABPC) >>
Rule(jump)   === << TRUE, JOIN LAB1 LABPC, __ >>
Rule(bnz)    === << TRUE, JOIN LAB1 LABPC, __ >>
Rule(call)   === << TRUE, JOIN LAB1 LABPC, LABPC >>
Rule(ret)    === << TRUE, LAB2, JOIN LAB1 LABPC >>
