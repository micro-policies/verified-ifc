
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Metavariable conventions

metavar o {{tex \mathord{\circ} }} ::=           {{com binary ops}}

metavar M {{tex \mu }} ::=      {{com abstract memory}}

metavar I {{tex \iota }} ::=      {{com instruction memory}}

metavar F {{tex \phi }} ::=      {{com tmu fault handler }}

metavar cM {{tex \boldsymbol{\mu} }} ::=      {{com concrete memory}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

n, m, k, p, npc {{tex n_\mathit{pc} }} :: 'n_' ::= {{com Integers}}
  | 0                       :: :: Zzro
  | 1                       :: :: Zone
  | n1 + n2                 :: :: ZPlus
  | n1 o n2                 :: :: ZBinOp
  | ( n1 = n2 ) ? n3 : n4   :: :: ZIf
  | ( n )                   :: S :: ZParen

L, K, Lpc {{tex L_\mathit{pc} }} :: 'L_' ::=   {{com Labels}}
  | bot                     :: :: Lbot      {{com bottom label}}
  | labOf a                 :: :: Labelof    {{com extract label of an atom}}
  | L1 \/ L2                :: :: Ljoin     {{com label join}}
  | ( L )                   :: S :: LParen

oL, l {{tex \ell }}  :: 'oL_' ::=   {{com Optional Labels}}
  | _                     :: :: Nothing {{tex \_}}
  | L                     :: :: SomeLabel

a, b, pc :: 'a_' ::=                       {{com Atoms}}
  | n @ L                   :: :: ValAtom {{com atom = integers value plus label}}
  | a \/ L                  :: :: Ajoin   {{com join [[L]] with atom's label}}
  | a + 1                   :: :: ANext   {{com increment offset part of code pointer }}
  | ( a )                   :: S :: AParen

instr :: 'instr_' ::=                              {{com Instructions}}
  | Nop                     :: :: iNop
  | Push n                  :: :: iPush    {{com push constant integer}}
  | Pop                     :: :: iPop
  | Dup                     :: :: iDup
  | BinOp o                 :: :: iBinOp   {{com binary op, returning integer}}
  | Jump                    :: :: iJump
  | Bnz n                   :: :: iBnz     {{com conditional relative jump}}
  | Call                    :: :: iBCall
  | Ret                     :: :: iBRet
  | Load                    :: :: iLoad    
  | Store                   :: :: iStore
  | Output                  :: :: iOutput  {{com output the top of the stack, tainted with pc}}
%  | Halt                    :: :: iHalt

opcode :: 'opcode_' ::=                              {{com Opcodes}}
  | nop                     :: :: oNop
  | push                    :: :: oPush    {{com push constant integer}}
  | pop                     :: :: oPop
  | dup                     :: :: oDup
  | binop                   :: :: oBinOp   {{com binary op, returning integer}}
  | jump                    :: :: oJump
  | bnz                     :: :: oBNZ     {{com conditional relative jump}}
  | call                    :: :: oBCall
  | ret                     :: :: oBRet
  | load                    :: :: oLoad    
  | store                   :: :: oStore
  | output                  :: :: oOutput  {{com output the top of the stack, tainted with pc}}
%  | halt                    :: :: oHalt

e :: 'e_' ::=                              {{com Events}}
  | epsilon                 :: :: epsilon {{com no event }}
  | n @ L                  :: :: intE  {{com observable value event }}
  | ( e )                   :: S :: eParen   

S {{tex \sigma }} :: 'S_' ::=                     {{com Stack}}
  | Smty                    :: :: Smty     {{com empty stack}}
  | a ; S                   :: :: Sdcons   {{com stack atom cons}}
  | pc ;; S         :: :: Srcons   {{com stack frame marker cons (with
                                         return pc and protecting label)}}
  % | S1 $ S2                 :: ::   Sappend  {{com stack append}}
  | [ S ]                   :: :: SParen
  % | [ a1 .. aj ]            :: :: SElems

LE, exprr {{tex expr_{res} }}, exprpc {{tex expr_{pc} }}  :: 'LE_' ::= {{com Label Expressions}}
  | BOT  :: :: eBOT  {{tex \mathtt{BOT} }}
  | LAB1 :: :: eLab1 {{tex \mathtt{LAB}_1}}
  | LAB2 :: :: eLab2 {{tex \mathtt{LAB}_2}}
  | LAB3 :: :: eLab3 {{tex \mathtt{LAB}_3}}
  | LABPC :: :: eLabPC {{tex \mathtt{LAB}_\mathit{pc} }}
  | JOIN LE1 LE2 :: :: eJoin 
  | __ :: :: DontCare
  | ( LE ) :: S :: eParen

BE, allow :: 'BE_' ::= {{com Boolean Expressions over Labels}}
  | TRUE :: :: bTrue                       
  | FLOWS LE1 LE2 :: :: bFlows             
  | AND BE1 BE2 :: :: bAnd                 
  | OR BE1 BE2 :: :: bOr                   
  | ( BE ) :: S :: bParen

RHS :: 'RHS' ::= {{com Right hand side of rules }}
  | << BE , LE1 , LE2 >> :: :: RightHandSide {{com Allow part, Result Label, Next PC label }}
  {{tex \langle [[BE]], [[LE1]], [[LE2]] \rangle }}

rho {{tex \rho }} :: 'rho_' ::= {{com Evaluation context for rules }}
  | ( l1 , l2 , l3 , l4 ) :: :: EvalCont {{com [[l1]] is pc label }}

% Concrete machine

priv {{tex \pi }} :: 'priv_' ::=                      {{com Privileged bit }}
  | upriv                   :: :: PbitOff  {{com user mode }}
  | kpriv                   :: :: PbitOn   {{com kernel mode  }}

T {{tex \mathtt{T} }}, 
R {{tex \mathtt{R} }}:: 'T_' ::=                 {{com Tags }}
  | Tbot                     :: :: Tbot      {{com default tag}}
  | _                       :: :: Tirrev    {{com irrelevant tag}}

ca {{tex \mathitbf{a} }}, cpc {{tex \mathitbf{pc} }} :: 'ca_' ::=    {{com Concrete Atoms}}
  | n @ T                   :: :: cAtom {{com atom = integers value plus tag}}
  | ca + 1                  :: :: cANext   {{com increment offset part of code pointer }}
  | ( ca )                  :: S :: cAParen

ce :: 'ce_' ::=                              {{com Events}}
  | cepsilon                 :: :: epsilon {{com no event }}
  | n @ T                  :: :: intE  {{com observable value event }}
  | ( ce )                   :: S :: eParen   

cS {{tex \boldsymbol{\sigma} }} :: 'cS_' ::=                     {{com Stack}}
  | cSmty                    :: :: cSmty     {{com empty stack}}
  | ca ; cS                  :: :: cSdcons   {{com stack atom cons}}
  | ( cpc , priv ) ;; cS     :: :: cSrcons   {{com stack frame marker cons (with return pc and priv bit )}}
  | [ cS ]                   :: :: cSParen

C {{tex \kappa }} :: 'C_' ::=    {{com TMU Caches = Opcode + 5-tuple of tags }}
  | ( opcode | T1 | T2 , T3 , T4 | T5 , T6 ) :: :: Cache {{com the whole cache}}
                  {{tex 
                    \begin{array}{|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}||@{\;}l@{\;}|@{\;}l@{\;}|}
                       \hline  
                          [[opcode]] & [[T1]] & [[T2]] & [[T3]] & [[T4]] & [[T5]] & [[T6]] \\ 
                       \hline
                       \end{array}
                     }}                  
   | [ ki , ko ]  :: :: CacheInOut   {{com  tmu cache inputs and outputs parts }}
                  {{tex [ [[ki]] , [[ko]] ] }}            

ki {{tex {\kappa_i} }},
kj {{tex {\kappa_j} }} :: 'ki_' ::= {{com  tmu cache input part }}
   | ( opcode | T1 | T2 , T3 , T4 ) :: :: CacheIn {{tex 
                    \begin{array}{|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|}
                       \hline  
                          [[opcode]] & [[T1]] & [[T2]] & [[T3]] & [[T4]] \\
                       \hline
                       \end{array}
                     }}

ko {{tex \kappa_o }} :: 'ko_' ::= {{com  tmu cache output part }}
   | ( T5 , T6 ) :: :: CacheOut {{tex 
                    \begin{array}{|@{\;}l@{\;}|@{\;}l@{\;}|}
                    \hline
                          [[T5]] & [[T6]] \\
                    \hline
                       \end{array}
                    }}
   |  kbot :: :: CacheOutDft 

kbot {{tex \kappa_{\_} }} :: ''  ::= {{com default output part of cache }}
   | ( _ , _ )  :: :: BotBot {{tex 
                   \begin{array}{|@{\;}l@{\;}|@{\;}l@{\;}|}
                   \hline
                          [[_]] & [[_]] \\
                   \hline
                    \end{array}
                    }}


formula :: formula_ ::=  
 | judgement                :: :: judgement
 | I ( pc ) = instr         :: :: pc_lookup  {{com instruction lookup (fails if pc not a code pointer)}}
 | I ( n ) = instr         :: :: instr_lookup  {{com instruction lookup }}
 | read M p = a             :: :: aload          {{com read from data memory }}
 | store M p a = M'         :: :: astore         {{com memory store of atom }}

 | flowsTo L1 L2 = n        :: :: flowsto       {{com binop operation on labels - return int  }}
 | n1 <> n2                 :: :: not_eq_int
 | n1 = n2                  :: :: eq_int
 % | M1 = M2                  :: :: eq_mem
 % | p1 <> p2                 :: :: not_eq_pntr
 % | p1 = p2                  :: :: eq_pntr
 | a1 = a2                  :: :: eq_atm
 | L1 <= L2                 :: :: labelLeq
 | L1 = L2                  :: :: labelEq
 | RHS1 = RHS2              :: :: rhs_eq

 | F ( n ) = instr         :: :: instr_lookup_priv  {{com fault handler instruction lookup }}
 | read cM p = ca             :: :: cread          {{com read from data memory }}
 | store cM p ca = cM'         :: :: cstore         {{com memory store of atom }}
 | read C p = ca             :: :: load_priv          {{com read from cache }}
 | store C p ca = C'         :: :: store_priv         {{com cache write of atom }}
 | C1 ~ C2                  :: :: cache_eq         {{com cache hit (equality of caches) }}
 
 | ki1 ~/~ ki2 ~ ki3        :: :: cache_neq         {{com cache input miss and update }}


 % | v1 = .. = vj = v         :: :: vals_eq
 % | formula1 ==> formula2    :: :: implication
 | formula1 quad formula2   :: :: savingspace


terminals :: 'terminals_' ::=
  | ==>                 :: :: eval       {{tex \Longrightarrow }}
  | quad                :: :: savespace  {{tex \qquad }}
  | \/                  :: :: join       {{tex \mathord{\vee} }}
  | |_|                 :: :: ljoin      {{tex \mathord{\sqcup} }}
  | <>                  :: :: noteq      {{tex \neq }}
  | @                   :: :: atlabel    {{tex \mathord{@} }}
  | ;;                  :: :: semisemi   {{tex \mathord{;\!;} }}
  | +                   :: :: plus       {{tex \mathord{+} }}
  | +1                  :: :: plusplus   {{tex {\scriptstyle \mathord{+\!+} } }}
  | |->                 :: :: mapsto     {{tex {\scriptstyle \mathord{\mapsto} } }}
  | forall              :: :: forall     {{tex \forall }}
  | <=                  :: :: le         {{tex \le }}
  | Smty                :: :: Smty       {{tex \text{\sf mty} }}
  | bot                 :: :: bot        {{tex \bot }}
  | <|                  :: :: lcp        {{tex \langle }}
  | |>                  :: :: rcp        {{tex \rangle }}

  | Call                :: :: Call       {{tex \text{\sf Call} }} 
  | Output              :: :: Output     {{tex \text{\sf Output} }}
  | Load                :: :: Load       {{tex \text{\sf Load} }} 
  | Store               :: :: Store      {{tex \text{\sf Store} }} 
  | Nop                 :: :: Nop        {{tex \text{\sf Nop} }}
  | Push                :: :: Push       {{tex \text{\sf Push} }} 
  | Pop                 :: :: Pop        {{tex \text{\sf Pop} }} 
  | Dup                 :: :: Dup        {{tex \text{\sf Dup} }} 
  | BinOp               :: :: BinOp      {{tex \text{\sf BinOp} }}
  | Jump                :: :: Jump       {{tex \text{\sf Jump} }} 
  | Bnz                 :: :: Bnz        {{tex \text{\sf Bnz} }} 
  | Ret                 :: :: Ret        {{tex \text{\sf Ret} }} 
%  | Halt                :: :: Halt       {{tex \text{\sf Halt} }} 

  | epsilon             :: :: eE0        {{tex \varepsilon }} 

  | TRUE                :: :: e_true     {{tex \texttt{TRUE} }}
  | FLOWS               :: :: e_flows    {{tex \texttt{FLOWS} }}
  | JOIN                :: :: e_join     {{tex \texttt{JOIN} }}
  | AND                 :: :: e_and      {{tex \mathtt{AND} }}
  | OR                  :: :: e_or       {{tex \mathtt{OR}  }}

  | cepsilon             :: :: ceE0       {{tex \varepsilon }} 
  | upriv               :: :: upriv     {{tex \text{\sf u} }} 
  | kpriv               :: :: kpriv      {{tex \text{\sf k} }} 
  | Tbot                :: :: Tbot        {{tex \mathtt{T}_{\bot} }}
  | ~                   :: :: match      {{tex = }}
  | ~/~                 :: :: dmatch     {{tex \not= }}

defns
AbstractHighLevelSmallStep :: '' ::=

  defn 
  M1 , I1 , S1 , pc1 -- e -> M2 , I2 , S2 , pc2  :: :: ahstep :: '' 
  {{tex [[M1]], [[S1]], [[pc1]] \xrightarrow{[[e]]} [[M2]], [[S2]], [[pc2]] }} by

     I(pc) = Nop
     ------------------------------------- :: Step_Nop
     M, I, S, pc -- epsilon -> M, I, S, pc+1

     I(pc) = Output
     -------------------------------------------------------- :: Step_Output
     M, I, [n@K; S], pc -- n @ K\/labOf(pc) -> M, I, S, pc+1

    % pointer offsetting won't be a binop, now stricter on the input values
    % they must be integers
     I(pc) = BinOp o
    -------------------------------------------------------- :: Step_BinOp
     M, I, [n1@L1; n1@L2; S], pc -- epsilon -> M, I, [(n1 o n2)@(L1\/L2); S], pc+1

     I(pc) = Push n
     -------------------------------------------------------- :: Step_Push
     M, I, S, pc -- epsilon -> M, I, [n @ bot; S], pc+1

     I(pc) = Load   quad    read M p = a
     -------------------------------------------------------- :: Step_Load
     M, I, [p@K; S], pc -- epsilon -> M, I, [a \/ K; S], pc+1

     I(pc) = Store    quad    read M p = n@L
     K \/ labOf(pc) <= L   quad   store M p (a \/ K \/ labOf(pc)) = M'
     -------------------------------------------------------- :: Step_Store
     M, I, [p@K; a; S], pc -- epsilon -> M', I, S, pc+1

     I(pc) = Jump
      -------------------------------------------------------- :: Step_Jump
     M, I, [pc'; S], pc -- epsilon -> M, I, S, pc' \/ labOf(pc)
    
     I(pc) = Bnz k  quad   m <> 0 
     -------------------------------------------------------- :: Step_Bnz_Yes
     M, I, [m@K; S], n@L -- epsilon -> M, I, S, (n+k)@L\/K
    
     I(pc) = Bnz k quad   m = 0 
     -------------------------------------------------------- :: Step_Bnz_No
     M, I, [m@K; S], n@L -- epsilon -> M, I, S, (n+1)@L\/ K

     I(pc) = Call
     -------------------------------------------------------- :: Step_Call
     M, I, [ pc' ; a ; S], pc -- epsilon -> M, I, [a; pc+1 ;; S], pc'\/labOf(pc)

     I(pc) = Ret
     -------------------------------------------------------- :: Step_Ret
     M, I, [a ; pc' ;; S], pc -- epsilon -> M, I, [a\/labOf(pc) ; S], pc'

     % I(pc) = Pop
     % -------------------------------------------------------- :: Step_Pop
     % M, I, [a; S], pc -- espilon -> M, I, S, pc+1

     % I(pc) = Swap
     % -------------------------------------------------------- :: Step_Swap
     % M, I, [a1; a2; S], pc -- espilon -> M, I, [a2; a1; S], pc+1

     % I(pc) = Ret
     % -------------------------------------------------------- :: Step_Ret_Pop
     % M, I, [a; a'; S], pc --epsilon -> M, I, [a; S], pc

     % M(pc) = Dup
     % -------------------------------------------------------- :: Step_Dup
     % M, [a; S], pc, T --> M, [a;a;S], pc+1, T



%%******* NEW RELATIONS FOR EXPLICIT RULES

    %  I(pc) = BinOp o   
    %  Binop, (L, L1, L2, _) |- rL, rpcl
    % -------------------------------------------------------- :: Step_BinOp
    %  M, I, [n1@L1; n1@L2; S], n@L -- epsilon -> M, I, [(n1 o n2)@rl; S], (n+1@rpcl)

    %  For irrelevant result labels 
    %  Binop, (L, L1, L2, _) |- _, rpcl
     
    % ------------------------------------- :: Rule_Binop
    % Binop |- TRUE, JOIN LAB1 LAB2, LABPC

    % I |- A, E1, E2
    % evalb rho A 
    % evall rho E1 l1  quad   evall rho E2 l2
    % ------------------------------------- :: eval
    % I , rho |- l1, l2

defns 
  RuleEvaluation :: '' ::= 

  defn 
  rho |-- LE oL  :: :: eval_expr :: '' {{tex [[rho]] \vdash  [[LE]] \downarrow [[oL]]}}
  by

   ------------------------------------ :: lbot
     (Lpc, l1, l2, l3)  |-- BOT bot
     
   ------------------------------------ :: lpc
     (Lpc, l1, l2, l3)  |-- LABPC Lpc

   ------------------------------------ :: var1
     (Lpc, L1, l2, l3)  |-- LAB1 L1

   ------------------------------------ :: var2
     (Lpc, l1, L2, l3)  |-- LAB2 L2

   ------------------------------------ :: var3
     (Lpc, l1, l2, L3)  |-- LAB3 L3

     rho |-- LE1 L1   quad    rho |-- LE2 L2 
   ------------------------------------------ :: join
     rho  |-- (JOIN LE1 LE2) (L1 \/ L2)

  defn 
  rho |- allow :: :: eval_cond :: '' {{tex [[rho]] \vdash  [[allow]] }}
  by

   ------------------ :: true
     rho  |- TRUE

     rho |-- LE1 L1  quad rho |-- LE2 L2 quad  L1 <= L2
   ------------------------------------------------------- :: flows
     rho  |- FLOWS LE1 LE2

     rho |- BE1  quad rho |- BE2
   ---------------------------------- :: and
     rho  |- AND BE1 BE2

     rho |- BE1  
   ---------------------------------- :: or1
     rho  |- OR BE1 BE2

     rho |- BE2  
   ---------------------------------- :: or2
     rho  |- OR BE1 BE2

  
  defn 
  rho ~~ opcode ~> L , oL'  :: :: run_tmr :: '' {{tex [[rho]]  \leadsto_{[[opcode]]} [[L]] , [[oL']] }}
  by
  
     Rule(opcode) = << allow, exprpc, exprr >>
     rho |- allow   quad   rho |--  exprpc Lpc     quad   rho |--  exprr K
   ------------------------------------------------------------------------------ :: eval_rule
     rho ~~ opcode ~> Lpc, K

     Rule(opcode) = << allow, exprpc, exprr >>
     rho |- allow   quad   rho |--  exprpc Lpc     
   ----------------------------------------------------- :: eval_rule_NoRes
     rho ~~ opcode ~> Lpc, _


defns
AbstractExplicitSmallStep :: '' ::=


  defn
  M1 , S1 , pc1 -- e -> M2 , S2 , pc2  :: :: aestep :: '' 
  {{tex [[M1]], [[S1]], [[pc1]] \xrightarrow{[[e]]} [[M2]], [[S2]], [[pc2]] }} by

     I(pc) = Nop
     (Lpc, _, _, _) ~~ nop ~> Lpc', _
     -------------------------------------- :: Nop
     M, S, npc@Lpc -- epsilon -> M, S, (npc+1)@Lpc'

     I(pc) = Output
     (Lpc, L1, _, _) ~~ output ~> Lpc', L'
     -------------------------------------------------------- :: Output
     M, [n@L1; S], npc@Lpc -- n@L' -> M, S, (npc+1)@Lpc'

     I(pc) = BinOp o
     (Lpc, L1, L2, _) ~~ binop ~> Lpc', L
    -------------------------------------------------------- :: BinOp
     M, [n1@L1; n1@L2; S], npc@Lpc -- epsilon -> M, [(n1 o n2)@L'; S], (npc+1)@Lpc'

     I(pc) = Push n
     (Lpc, _, _, _) ~~ push ~> Lpc', L'
     -------------------------------------------------------- :: Push
     M, S, npc@Lpc -- epsilon -> M, [n@L'; S], (npc+1)@Lpc'

     I(pc) = Load   quad    read M p = n@L2
     (Lpc, L1, L2, _) ~~ load ~> Lpc', L'
     -------------------------------------------------------- :: Load
     M, [p@L1; S], pc -- epsilon -> M, [n@L'; S], (npc+1)@Lpc'

     I(pc) = Store    quad    read M p = n@L3
     (Lpc, L1, L2, L3) ~~ store ~> Lpc', L'
     store M p m@L' = M'
     -------------------------------------------------------- :: Store
     M, [p@L1; m@L2; S], npc@Lpc -- epsilon -> M', S, (npc+1)@Lpc'

     I(pc) = Jump
     (Lpc, L1, _, _) ~~ jump ~> Lpc', _
      ------------------------------------------------------- :: Jump
     M, [n@L1; S], npc@Lpc -- epsilon -> M, S, n@Lpc'
    
     I(pc) = Bnz k  quad   m <> 0 
     (Lpc, L1, _, _) ~~ bnz ~> Lpc', _
     -------------------------------------------------------- :: Bnz_Yes
     M, [m@L1; S], npc@Lpc -- epsilon -> M, S, (npc+k)@Lpc
    
     I(pc) = Bnz k quad   m = 0
     (Lpc, L1, _, _) ~~ bnz ~> Lpc', _
     -------------------------------------------------------- :: Bnz_No
     M, [m@L1; S], npc@Lpc -- epsilon -> M, S, (npc+1)@Lpc

     % CH: This is not at all in sync with the Coq code
     % CH: "a" could be expanded out, its label passed into the TMU
     %         and returned out as a 3rd(!?) argument? Ouch!
     I(pc) = Call
     (Lpc, L1, _, _) ~~ call ~> Lpc', L'
     -------------------------------------------------------- :: Call
     M, [ n@L1 ; a ; S], npc@Lpc -- epsilon -> M, [a; (npc+1)@L' ;; S], n@Lpc'

     % CH: This corresponds to VRet in the Coq code
     I(pc) = Ret
     (Lpc, L1, L2, _) ~~ ret ~> Lpc', L'
     -------------------------------------------------------- :: Ret
     M, [n@L1 ; m@L2 ;; S], npc@Lpc -- epsilon -> M, [n@L' ; S], m@Lpc'

funs
      Rule ::=
    fun
      Rule ( opcode ) :: RHS :: rule
    by
Rule(nop)    === << TRUE, LABPC, __ >>
Rule(output) === << TRUE, LABPC, JOIN LAB1 LABPC >>
Rule(binop)  === << TRUE, LABPC, JOIN LAB1 LAB2 >>
Rule(push)   === << TRUE, LABPC, BOT >>
Rule(load)   === << TRUE, LABPC, JOIN LAB1 LAB2 >>
Rule(store)  === << FLOWS (JOIN LAB1 LABPC) LAB3, LABPC, JOIN LAB1 (JOIN LAB2 LABPC) >>
Rule(jump)   === << TRUE, JOIN LAB1 LABPC, __ >>
Rule(bnz)    === << TRUE, JOIN LAB1 LABPC, __ >>
Rule(call)   === << TRUE, JOIN LAB1 LABPC, LABPC >>
Rule(ret)    === << TRUE, LAB2, JOIN LAB1 LABPC >>


% Concrete machine rules

defns
ConcreteSmallStep :: '' ::=

  defn
  priv1 , C1 , F1 , cM1 , I1 , cS1 , cpc1 -- ce -> priv2 , C2 , F2 , cM2 , I2 , cS2 , cpc2  :: :: cstep :: 'C' 
  {{tex \def\arraystretch{.7}
  \setlength\arraycolsep{2pt} \begin{array}{lclrlc}
  [[priv1]] & [[C1]] & [[cM1]] & [[cS1]] & [[cpc1]] & \xrightarrow{[[ce]]} \\
  [[priv2]] & [[C2]] & [[cM2]] & [[cS2]] & [[cpc2]]
  \end{array} }} by

     I(n) = Nop
     C ~ (nop | T | _, _, _ | R, _)         
     ------------------------------------- :: Nop
     upriv, C, F, cM, I, cS, n@T -- cepsilon -> upriv, C, F, cM, I, cS, n+1@R

     I(n) = Nop
     ki ~/~ (nop | T | _, _, _) ~ kj
     ------------------------------------- :: Nop_F
     upriv, [ki,ko], F, cM, I, cS, n@T -- cepsilon -> kpriv, [kj,kbot], F, cM, I, [(n@T, upriv) ;; cS], 0@Tbot

     F(n) = Nop
     ------------------------------------- :: Nop_P
     kpriv, C, F, cM, I, cS, n@T -- cepsilon -> kpriv, C, F, cM, I, cS, n+1@T

     I(n) = Output
     C ~ (output | T | T1, _, _| R1, R2)         
     -------------------------------------------------------- :: Out
     upriv, C, F, cM, I, [m@T1; cS], n@T -- m@R2 -> upriv, C, F, cM, I, cS, n+1@R1

     I(n) = Output
     ki ~/~ (output | T | T1, _, _) ~ kj
     -------------------------------------------------------- :: Out_F
     upriv, [ki,ko], F, cM, I, [m@T1; cS], n@T -- cepsilon -> kpriv, [kj,kbot], F, cM, I, [(n@T,upriv) ;; m@T1 ; cS], 0@Tbot

     I(n) = BinOp o
     C ~ (binop | T | T1, T2, _| R1, R2) 
    -------------------------------------------------------- :: BOp
     upriv, C, F, cM, I, [n1@T1; n2@T2; cS], n@T -- cepsilon -> upriv, C, F, cM, I, [(n1 o n2)@R2; cS], n+1@R1

     I(n) = BinOp o
     ki ~/~ ( binop | T | T1, T2, _) ~ kj
    -------------------------------------------------------- :: BOp_F
     upriv, [ki,ko], F, cM, I, [n1@T1; n1@T2; cS], n@T -- cepsilon -> kpriv, [kj,kbot], F, cM, I, [ (n@T,upriv);; n1@T1; n1@T2 ; cS], 0@Tbot

     F(n) = BinOp o
    -------------------------------------------------------- :: BOp_P
     kpriv, C, F, cM, I, [n1@T1; n1@T2; cS], n@T -- cepsilon -> kpriv, C, F, cM, I, [(n1 o n2)@T; cS], n+1@T
     
     I(n) = Push m
     C ~ ( push | T | _, _, _| R1, R2)
     -------------------------------------------------------- :: Psh
     upriv, C, F, cM, I, cS, n@T -- cepsilon -> upriv, C, F, cM, I, [m @ R2; cS], n+1@R1

     I(n) = Push m
     ki ~/~ ( push | T | _, _, _) ~ kj
     -------------------------------------------------------- :: Psh_F
     upriv, [ki,ko], F, cM, I, cS, n@T -- cepsilon -> kpriv, [kj,kbot], F, cM, I, [(n@T,upriv) ;; cS], 0@Tbot

     F(n) = Push m
     -------------------------------------------------------- :: Psh_P
     kpriv, C, F, cM, I, cS, n@T -- cepsilon -> kpriv, C, F, cM, I, [m @ Tbot; cS], n+1@T

     I(n) = Load
     read cM p = m@T2
     C ~ ( load | T | T1, T2, _| R1, R2)
     -------------------------------------------------------- :: Ld
     upriv, C, F, cM, I, [p@T1; cS], n@T -- cepsilon -> upriv, C, F, cM, I, [m@R2; cS], n+1@R1

     I(n) = Load
     read cM p = m@T2
     ki ~/~ ( load | T | T1, T2, _) ~ kj
     -------------------------------------------------------- :: Ld_F
     upriv, [ki,ko], F, cM, I, [p@T1; cS], n@T -- cepsilon -> kpriv, [kj,kbot], F, cM, I, [(n@T,upriv) ;; p@T1; cS], 0@Tbot

     F(n) = Load
     read C p = m@T2
     -------------------------------------------------------- :: Ld_P
     kpriv, C, F, cM, I, [p@T1; cS], n@T -- cepsilon -> kpriv, C, F, cM, I, [m@T2; cS], n+1@T

     I(n) = Store    quad    read cM p = m@T3
     C ~ ( store | T | T1, T2, T3| R1, R2) 
     store cM p (m@R2) = cM'
     -------------------------------------------------------- :: St
     upriv, C, F, cM, I, [p@T1; m@T2; cS], n@T -- cepsilon -> upriv, C, F, cM', I, cS, n+1@R1

     I(n) = Store    quad    read cM p = m@T3
     ki ~/~ ( store | T | T1, T2, T3)  ~ kj
     -------------------------------------------------------- :: St_F
     upriv, [ki,ko], F, cM, I, [p@T1; m@T2; cS], n@T -- cepsilon -> kpriv, [kj,kbot], F, cM, I, [ (n@T,upriv) ;; p@T1; m@T2; cS], 0@Tbot 

     F(n) = Store    
     store C p (m@T2) = C'
     -------------------------------------------------------- :: St_P
     kpriv, C, F, cM, I, [p@T1; m@T2; cS], n@T -- cepsilon -> kpriv, C', F, cM, I, cS, n+1@T

     I(n) = Jump
     C ~ ( jump | T | T1, _, _| R1, _)
      -------------------------------------------------------- :: Jmp
     upriv, C, F, cM, I, [m@T1; cS], n@T -- cepsilon -> upriv, C, F, cM, I, cS, m@R1

     I(n) = Jump
     ki ~/~ ( jump | T | T1, _, _) ~ kj
      -------------------------------------------------------- :: Jmp_F
     upriv, [ki,ko], F, cM, I, [m@T1; cS], n@T -- cepsilon -> kpriv, [kj,kbot], F, cM, I, [ (n@T,upriv) ;; m@T1 ; cS], 0@Tbot

     F(n) = Jump
      -------------------------------------------------------- :: Jmp_P
     kpriv, C, F, cM, I, [m@T1; cS], n@T -- cepsilon -> kpriv, C, F, cM, I, cS, m@T

     I(n) = Bnz m
     C ~ ( bnz | T | T1, _, _| R1, _)
     n' = n + (k = 0)? 1 : m  
     -------------------------------------------------------- :: Bnz
     upriv, C, F, cM, I, [k@T1; cS], n@T -- cepsilon -> upriv, C, F, cM, I, cS, n'@R1
    
     I(n) = Bnz m
     ki ~/~ ( bnz | T | T1, _, _) ~ kj
     -------------------------------------------------------- :: Bnz_F
     upriv, [ki,ko], F, cM, I, [k@T1; cS], n@T -- cepsilon -> kpriv, [kj,kbot], F, cM, I, [ (n@T,upriv) ;; k@T1 ; cS], 0@Tbot

     F(n) = Bnz m
     n' = n + (k = 0)? 1 : m
     -------------------------------------------------------- :: Bnz_P
     kpriv, C, F, cM, I, [k@T1; cS], n@T -- cepsilon -> kpriv, C, F, cM, I, cS, n'@T

     I(n) = Call
     C ~ ( call | T | T1, _, _| R1, R2)
     -------------------------------------------------------- :: Cll
     upriv, C, F, cM, I, [ p@T1 ; ca ; cS], n@T -- cepsilon -> upriv, C, F, cM, I, [ca; (n+1@R2,upriv) ;; cS], p@R1

     I(n) = Call
     ki ~/~ ( call | T | T1, _, _) ~ kj
     -------------------------------------------------------- :: Cll_F
     upriv, [ki,ko], F, cM, I, [ p@T1 ; ca ; cS], n@T -- cepsilon -> kpriv, [kj,kbot], F, cM, I, [ (n@T,upriv) ;; p@T1 ; ca ; cS], 0@Tbot

     % CH: why not p@T in the result?
     F(n) = Call
     -------------------------------------------------------- :: Cll_P
     kpriv, C, F, cM, I, [ p@T1 ; ca ; cS], n@T -- cepsilon -> kpriv, C, F, cM, I, [ca; (n+1@T,kpriv) ;; cS], p@T1

     I(n) = Ret
     C ~ ( ret | T | T1, T2, _| R1, R2)
     -------------------------------------------------------- :: Ret
     upriv, C, F, cM, I, [m@T1 ; (p@T2,priv) ;; cS], n@T -- cepsilon -> priv, C, F, cM, I, [m@R2 ; cS], p@R1

     I(n) = Ret
     ki ~/~ ( ret | T | T1, T2, _) ~ kj
     -------------------------------------------------------- :: Ret_F
     upriv, [ki,ko], F, cM, I, [k@T1 ; (p@T2,priv) ;; cS], n@T -- cepsilon -> kpriv, [kj,kbot], F, cM, I, [ (n@T,upriv) ;; k@T1 ; (p@T2,priv) ;; cS], 0@Tbot

     F(n) = Ret
     -------------------------------------------------------- :: Ret_P
     kpriv, C, F, cM, I, [(p@T1,priv) ;; cS], n@T -- cepsilon -> priv, C, F, cM, I, cS, p@T1

     % I(pc) = Pop
     % -------------------------------------------------------- :: Pop
     % cM, I, [a; cS], pc -- espilon -> cM, I, cS, pc+1

     % I(pc) = Swap
     % -------------------------------------------------------- :: Swap
     % cM, I, [a1; a2; cS], pc -- espilon -> cM, I, [a2; a1; cS], pc+1

     % I(pc) = Ret
     % -------------------------------------------------------- :: Ret_Pop
     % cM, I, [a; a'; cS], pc --cepsilon -> cM, I, [a; cS], pc

     % cM(pc) = Dup
     % -------------------------------------------------------- :: Dup
     % cM, [a; cS], pc, T --> cM, [a;a;cS], pc+1, T
    


