\documentclass{article}

\usepackage{amsmath,amssymb,amsthm}
\usepackage{stmaryrd}
\usepackage{supertabular}
\usepackage{fullpage}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{fancyvrb}
\usepackage{latexsym}
\usepackage{bm}

\input{temp/defns}

\renewcommand{\ottkw}[1]{\mathsf{#1}}

\DeclareMathAlphabet{\mathitbf}{OT1}{cmr}{bx}{it}

\definecolor{dkblue}{rgb}{0,0.1,0.5}
\definecolor{dkgreen}{rgb}{0,0.3,0}
\definecolor{dkred}{rgb}{0.6,0,0}

\newcommand{\comm}[3]{\textcolor{#1}{[#2: #3]}}
\newcommand{\ch}[1]{\comm{violet}{CH}{#1}} % Catalin
\newcommand{\bcp}[1]{\comm{dkred}{BCP}{#1}} % Benjamin
\newcommand{\dd}[1]{\comm{dkblue}{DD}{#1}} % Delphine


\begin{document}

\section*{Some old Notes}

\begin{itemize}
\item Ott file for the current pico machine with output, with inlined rules.
  \begin{itemize}
  \item memory for instruction and data are separate
  \item pointers are just index into a list
  \item no atom in the syntax of a program, just integers
  \item only one type of call (with 1 argument)
  \item values are just integers
  \end{itemize}
\item Other "simplifications" made, compared to the Coq def
  (these should be reflected in Coq soon)
  \begin{itemize}
    \item the two rules for the return (popping until reaching the
      last element before call frame marker)
  \end{itemize}
\item TODO, TOCHANGE: 
  \begin{itemize}
    \item Machine with explicit rules implicitly uses the convention that 
      $n_{pc}@L_{pc} = pc$
  \end{itemize}
\end{itemize}

\section*{Syntax}

\ottmetavars\\[3ex]

\ottgrammartabular{
%% \ottM\ottinterrule
%% \ottframe\ottinterrule
\ottn\ottinterrule
%% \ottp\ottinterrule
%% \ottv\ottinterrule
%% \ottov\ottinterrule
\ottL\ottinterrule
\otta\ottinterrule
\ottinstr\ottinterrule
%% \ottilab\ottinterrule
%\ottipseudo\ottinterrule
%% \ottireg\ottinterrule
%% \ottT\ottinterrule
\ottS\ottinterrule
%% \ottal\ottinterrule
}

% \section*{Auxiliary relations}

% \ottgrammartabular{
% \ottformula\ottinterrule
% }

\newpage
\section*{High-level Abstract Machine}

\ottdefnsAbstractHighLevelSmallStep

% \begin{quote}
% \ottgrammartabular{%
%    \ottC\ottinterrule
%    \ottt\ottinterrule
%    \ottu\ottinterrule
%    \ottv\ottinterrule
%    \ottG\ottinterrule
%    \ottbuf\ottinterrule
% }
% \end{quote}

\newpage
\section*{Intermediate Abstract Machine
  with Explicit Rules}

\subsection*{Rules : syntax, rule table, rule evaluation}

\ottgrammartabular{
\ottLE\ottinterrule
\ottBE\ottinterrule
\ottRHS\ottinterrule
\ottrho\ottinterrule
}

\ottfundefnsRule

\begin{ottdefnblock}[#1]{$ \rho  \vdash   \ottnt{allow} $}{}
\[ \ottdruletrue \ottinterrule
   \quad \ottdruleflows\ottinterrule \]
\[ \ottdruleand\ottinterrule 
   \quad \ottdruleorOne\ottinterrule
   \quad \ottdruleorTwo\ottinterrule \]
\end{ottdefnblock}

\clearpage
\begin{ottdefnblock}[#1]{$ \rho  \vdash \ottnt{LE} \downarrow  \ottnt{oL} $}{}
\small 
\[ \ottdrulelbot \ottinterrule
   \quad \ottdrulelpc \ottinterrule
   \quad \ottdrulejoin \ottinterrule \]
\[ \ottdrulevarOne \ottinterrule
   \quad \ottdrulevarTwo \ottinterrule
   \quad \ottdrulevarThree \ottinterrule \]
\end{ottdefnblock}

\ottdefnrunXXtmr

\clearpage

\subsection*{Small step relation}

\ottdefnsAbstractExplicitSmallStep

\section*{Notes (concrete machine)}

\renewcommand{\ottdrulename}[1]{\footnotesize\textsc{#1}}
\renewcommand{\ottdrule}[4][]
           {{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}
               %% ~\ottdrulename{#4}
           }}

\begin{itemize}
\item Ott file for the current concrete pico machine with output.
  \begin{itemize}
    \item the user program and tmu fault handler code are implicit,
      and global to the step relation
    \item labels are represented with integers. TODO: change for
      richer data structures. Need to introduce an extra privileged
      memory for that.
    \item how to present the fault handler? Nathan's
      combinators may help the ease of presentation too.
    \item notation for fault handler cache: only payload-labels are
      specified and not their labels. these could be any labels actually.
    \item when IFC-faulting, no effect on the memory (see rule for
      Store), and the stack below the frame of the tmu fault handler
      is also unchanged, so that, when returning from it, we can
      "replay" the instruction, with a cache that is up-to-date.
  \end{itemize}
\item Questions:
  \begin{itemize}
    \item Strictly speaking, the rule for Call is returning three
      things: the next pc for callee, the next pc inside the caller,
      and the label to put on the argument passed to the function.
      this ought to be fixed, I would say. For now: just two results.
      \dd{Having all outputs coming from the TMU manager would be more
        uniform}. \bcp{Stick to two outputs, and explain that in the
        text (less hardware resource usage)}
    \item Output and privileged mode: we can either make it blocking
      (saving one rule), or make it step, but observe that the tmu
      fault handler code do use output instruction. Made it blocking
      for now.
    \item Returning from priv mode to user mode: it's wrong
      to return a value here. For now, Ret is a value return at the
      abstract level, and a void return in priv mode. Need to
      reintroduce two kinds of return instruction?
    \item For a cache size greater than 1, the notation for
      cache-miss-and-update is likely to change.
    \item Cache miss-and-update: shouldn't trigger any non-determinism.
    \item $\bot$ should really denote a default (arbitrary, fixed)
      integer label, rather than the $\bot$ element of a concrete lattice.
      Need to choose a good notation for that.
  \end{itemize}
\end{itemize}

\section*{Syntax}

\ottmetavars\\[3ex]

\ottgrammartabular{
%% \ottM\ottinterrule
%% \ottframe\ottinterrule
\ottn\ottinterrule
%% \ottp\ottinterrule
%% \ottv\ottinterrule
%% \ottov\ottinterrule
\ottpriv\ottinterrule
\ottT\ottinterrule
\ottC\ottinterrule
\ottki\ottinterrule
\ottko\ottinterrule
\ottkbot\ottinterrule
\ottca\ottinterrule
\ottinstr\ottinterrule
%% \ottopcode\ottinterrule
\ottcS\ottinterrule
}

\section*{Auxiliary relations}

\ottgrammartabular{
\ottformula\ottinterrule
}

\clearpage
\section*{Step relation: user mode - hit/faulting, kernel mode}

\[ \ottdruleCNop \ottinterrule 
   \quad \quad \ottdruleCNopXXF \ottinterrule \]
\[ \ottdruleCOut \ottinterrule
   \quad \quad  \ottdruleCOutXXF \ottinterrule \]
\[ \ottdruleCBOp \ottinterrule
   \quad \quad \ottdruleCBOpXXF \ottinterrule \]
\[ \ottdruleCPsh \ottinterrule 
   \quad \quad \ottdruleCPshXXF \ottinterrule \]
 \[ \ottdruleCLd \ottinterrule 
   \quad \quad \ottdruleCLdXXF \ottinterrule \]
\[ \ottdruleCSt \ottinterrule
   \quad \quad \ottdruleCStXXF \ottinterrule \]
\[ \ottdruleCJmp \ottinterrule
   \quad \quad \ottdruleCJmpXXF \ottinterrule \]
\[ \ottdruleCBnz \ottinterrule 
   \quad \quad  \ottdruleCBnzXXF \ottinterrule  \] 
\[ \ottdruleCCll \ottinterrule
   \quad \quad  \ottdruleCCllXXF \ottinterrule \]
\[ \ottdruleCRet \ottinterrule   
   \quad \quad  \ottdruleCRetXXF \ottinterrule \]

\section*{Step relation: privileged mode}

\[ \ottdruleCNopXXP \ottinterrule \]
\[ \ottdruleCBOpXXP \ottinterrule \]
\[ \ottdruleCPshXXP \ottinterrule \]
\[ \ottdruleCLdXXP \ottinterrule \]
\[ \ottdruleCStXXP \ottinterrule \]
\[ \ottdruleCJmpXXP \ottinterrule \]
\[ \ottdruleCBnzXXP \ottinterrule \] 
\[ \ottdruleCCllXXP \ottinterrule \]
\[ \ottdruleCRetXXP \ottinterrule \] 


% \begin{quote}
% \ottgrammartabular{%
%    \ottC\ottinterrule
%    \ottt\ottinterrule
%    \ottu\ottinterrule
%    \ottv\ottinterrule
%    \ottG\ottinterrule
%    \ottbuf\ottinterrule
% }
% \end{quote}

\end{document}

% LocalWords:  BCP TODO
