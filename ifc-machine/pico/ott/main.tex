\documentclass{article}

\usepackage{amsmath,amssymb,amsthm}
\usepackage{stmaryrd}
\usepackage{supertabular}
\usepackage{fullpage}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{fancyvrb}
\usepackage{latexsym}

\input{temp/defns}

\renewcommand{\ottkw}[1]{\mathsf{#1}}

\definecolor{dkblue}{rgb}{0,0.1,0.5}
\definecolor{dkgreen}{rgb}{0,0.3,0}
\definecolor{dkred}{rgb}{0.6,0,0}

\newcommand{\comm}[3]{\textcolor{#1}{[#2: #3]}}
\newcommand{\ch}[1]{\comm{violet}{CH}{#1}} % Catalin
\newcommand{\bcp}[1]{\comm{dkred}{BCP}{#1}} % Benjamin
\newcommand{\dd}[1]{\comm{dkblue}{DD}{#1}} % Delphine

\begin{document}

\section*{Notes}

\begin{itemize}
\item Ott file for the current pico machine with output, with inlined rules.
  \begin{itemize}
  \item memory for instruction and data are separate
  \item pointers are just index into a list
  \item no atom in the syntax of a program, just integers
  \item only one type of call (with 1 argument)
  \item values are just integers
  \end{itemize}
\item Other "simplifications" made, compared to the Coq def
  (these should be reflected in Coq soon)
  \begin{itemize}
    \item the two rules for the return (popping until reaching the
      last element before call frame marker)
  \end{itemize}
\item TODO, TOCHANGE: 
  \begin{itemize}
    \item Machine with explicit rules implicitly uses the convention that 
      $n_{pc}@L_{pc} = pc$
  \end{itemize}
\end{itemize}

\section*{Syntax}

\ottmetavars\\[3ex]

\ottgrammartabular{
%% \ottM\ottinterrule
%% \ottframe\ottinterrule
\ottn\ottinterrule
%% \ottp\ottinterrule
%% \ottv\ottinterrule
%% \ottov\ottinterrule
\ottL\ottinterrule
\otta\ottinterrule
\ottinstr\ottinterrule
%% \ottilab\ottinterrule
%\ottipseudo\ottinterrule
%% \ottireg\ottinterrule
%% \ottT\ottinterrule
\ottS\ottinterrule
%% \ottal\ottinterrule
}

% \section*{Auxiliary relations}

% \ottgrammartabular{
% \ottformula\ottinterrule
% }

\newpage
\section*{High-level Abstract Machine}

\ottdefnsAbstractHighLevelSmallStep

% \begin{quote}
% \ottgrammartabular{%
%    \ottC\ottinterrule
%    \ottt\ottinterrule
%    \ottu\ottinterrule
%    \ottv\ottinterrule
%    \ottG\ottinterrule
%    \ottbuf\ottinterrule
% }
% \end{quote}

\newpage
\section*{Intermediate Abstract Machine
  with Explicit Rules}

\subsection*{Rules : syntax, rule table, rule evaluation}

\ottgrammartabular{
\ottLE\ottinterrule
\ottBE\ottinterrule
\ottRHS\ottinterrule
\ottrho\ottinterrule
}

\ottfundefnsRule

\begin{ottdefnblock}[#1]{$ \rho  \vdash   \ottnt{allow} $}{}
\[ \ottdruletrue \ottinterrule
   \quad \ottdruleflows\ottinterrule \]
\[ \ottdruleand\ottinterrule 
   \quad \ottdruleorOne\ottinterrule
   \quad \ottdruleorTwo\ottinterrule \]
\end{ottdefnblock}

\clearpage
\begin{ottdefnblock}[#1]{$ \rho  \vdash \ottnt{LE} \downarrow  \ottnt{oL} $}{}
\small 
\[ \ottdrulelbot \ottinterrule
   \quad \ottdrulelpc \ottinterrule
   \quad \ottdrulejoin \ottinterrule \]
\[ \ottdrulevarOne \ottinterrule
   \quad \ottdrulevarTwo \ottinterrule
   \quad \ottdrulevarThree \ottinterrule \]
\end{ottdefnblock}

\ottdefnrunXXtmr

\clearpage

\subsection*{Small step relation}

\ottdefnsAbstractExplicitSmallStep

\end{document}

% LocalWords:  canElim canReclassify injective Elim Recl TL BCP TODO
% LocalWords:  canEliminate newprin
