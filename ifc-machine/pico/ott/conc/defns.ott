
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Metavariable conventions

metavar o {{tex \mathord{\circ} }} ::=           {{com binary ops}}

metavar F {{tex \phi }} ::=      {{com tmu fault handler }}

metavar I {{tex \iota }} ::=      {{com instruction memory}}

metavar M {{tex \mu }} ::=      {{com memory}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

n, m, k, p :: 'n_' ::=                                {{com Integers}}
  | 0                       :: :: Zzro
  | 1                       :: :: Zone
  | n1 + n2                 :: :: ZPlus
  | n1 o n2                 :: :: ZBinOp  
  | ( n )                   :: S :: ZParen

b :: 'b_' ::=                         {{com Privileged bit }}
  | upriv                       :: :: PbitOff {{com ON }}
  | priv                       :: :: PbitOn  {{com OFF }}

L, K, R :: 'L_' ::=                  {{com Labels }}
  | bot                     :: :: Lbot      {{com bottom label}}
  | _                       :: :: Lirrev      {{com irrelevant label}}
  | ( L )                   :: S :: LParen

a, pc :: 'a_' ::=                       {{com Atoms}}
  | n @ L                   :: :: ValAtom {{com atom = integers value plus label}}
  | a + 1                   :: :: ANext   {{com increment offset part of code pointer }}
  | ( a )                   :: S :: AParen

instr :: 'instr_' ::=                              {{com Instructions}}
  | Nop                     :: :: iNop
  | Push n                  :: :: iPush    {{com push constant integer}}
  | Pop                     :: :: iPop
  | Dup                     :: :: iDup
  | BinOp o                 :: :: iBinOp   {{com binary op, returning integer}}
  | Jump                    :: :: iJump
  | BNZ n                   :: :: iBNZ     {{com conditional relative jump}}
  | Call                    :: :: iBCall
  | Ret                     :: :: iBRet
  | Load                    :: :: iLoad    
  | Store                   :: :: iStore
  | Output                  :: :: iOutput  {{com output the top of the stack, tainted with pc}}
  | Halt                    :: :: iHalt

e :: 'e_' ::=                              {{com Events}}
  | epsilon                 :: :: epsilon {{com no event }}
  | n @ L                  :: :: intE  {{com observable value event }}
  | ( e )                   :: S :: eParen   

S {{tex \sigma }} :: 'S_' ::=                     {{com Stack}}
  | Smty                    :: :: Smty     {{com empty stack}}
  | a ; S                   :: :: Sdcons   {{com stack atom cons}}
  | ( pc , b ) ;; S         :: :: Srcons   {{com stack frame marker cons (with return pc and priv bit )}}
  % | S1 $ S2                 :: ::   Sappend  {{com stack append}}
  | [ S ]                   :: :: SParen
  % | [ a1 .. aj ]            :: :: SElems

C {{tex \kappa }} :: 'C_' ::=    {{com TMU Caches = a 5-tuple of labels }}
  | ( instr | L1 | L2 , L3 , L4 | L5 , L6 ) :: :: Cache {{tex 
  \begin{array}{|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|}
        \hline
        [[instr]] & [[L1]] & [[L2]] & [[L3]] & [[L4]] & [[L5]] & [[L6]] \\ 
        \hline
        \end{array}
   }} 
% \framebox{[[L2]]}\framebox{[[L3]]}\framebox{[[L4]]}\framebox{[[L5]]}\framebox{[[L6]]}
  
  
formula :: formula_ ::=  
 | judgement                :: :: judgement
 | I ( n ) = instr         :: :: instr_lookup  {{com instruction lookup }}
 | F ( n ) = instr         :: :: priv_instr_lookup  {{com instruction lookup in fault handler code }}
 | read M p = a             :: :: load          {{com read from data memory }}
 | store M p a = M'         :: :: store         {{com memory store of atom }}

 | n1 <> n2                 :: :: not_eq_int
 | n1 = n2                  :: :: eq_int
 | M1 = M2                  :: :: eq_mem
 | p1 <> p2                 :: :: not_eq_pntr
 | p1 = p2                  :: :: eq_pntr
 | a1 = a2                  :: :: eq_atm
 | L1 = L2                  :: :: labelEq

 | C1 = C2                  :: :: cache_eq         {{com cache hit (equality of caches) }}
 
 | C1 <> C2 = C3            :: :: cache_neq         {{com cache miss and update }}

 % | v1 = .. = vj = v         :: :: vals_eq
 % | formula1 ==> formula2    :: :: implication
 | formula1 quad formula2   :: :: savingspace

terminals :: 'terminals_' ::=
  | ==>                 :: :: eval       {{tex \Longrightarrow }}
  | quad                :: :: savespace  {{tex \qquad }}
  | \/                  :: :: join       {{tex \mathord{\vee} }}
  | |_|                 :: :: ljoin      {{tex \mathord{\sqcup} }}
  | <>                  :: :: noteq      {{tex \neq }}
  | @                   :: :: atlabel    {{tex \mathord{@} }}
  | ;;                  :: :: semisemi   {{tex \mathord{;\!;} }}
  | +                   :: :: plus       {{tex \mathord{+} }}
  | +1                  :: :: plusplus   {{tex {\scriptstyle \mathord{+\!+} } }}
  | |->                 :: :: mapsto     {{tex {\scriptstyle \mathord{\mapsto} } }}
  | forall              :: :: forall     {{tex \forall }}
  | <=                  :: :: le         {{tex \le }}
  | Smty                :: :: Smty       {{tex \text{\sf mty} }}
  | bot                 :: :: bot        {{tex \bot }}
  | <|                  :: :: lcp        {{tex \langle }}
  | |>                  :: :: rcp        {{tex \rangle }}

  | Call                :: :: Call      {{tex \text{\sf Call} }} 
  | Output              :: :: Output    {{tex \text{\sf Output} }}
  | Load                :: :: Load       {{tex \text{\sf Load} }} 
  | Store               :: :: Store      {{tex \text{\sf Store} }} 
  | Nop                 :: :: Nop        {{tex \text{\sf Nop} }}
  | Push                :: :: Push       {{tex \text{\sf Push} }} 
  | Pop                 :: :: Pop        {{tex \text{\sf Pop} }} 
  | Dup                 :: :: Dup        {{tex \text{\sf Dup} }} 
  | BinOp               :: :: BinOp      {{tex \text{\sf BinOp} }}
  | Jump                :: :: Jump       {{tex \text{\sf Jump} }} 
  | BNZ                 :: :: BNZ        {{tex \text{\sf BNZ} }} 
  | Ret                 :: :: Ret        {{tex \text{\sf Ret} }} 
  | Halt                :: :: Halt       {{tex \text{\sf Halt} }} 

  | epsilon             :: :: eE0       {{tex \varepsilon }} 
  | upriv               :: :: upriv     {{tex 0 }} 
  | priv                :: :: priv      {{tex 1 }} 

defns
SmallStepEval :: '' ::=

  defn 
  b1 , C1 , F1 , M1 , I1 , S1 , pc1 -- e -> b2 , C2 , F2 , M2 , I2 , S2 , pc2  :: :: step :: '' 
  {{tex [[b1]], [[C1]], [[M1]], [[S1]], [[pc1]] \xrightarrow{[[e]]} [[b2]], [[C2]], [[M2]], [[S2]], [[pc2]] }} by

     I(n) = Nop
     C = (Nop | L | _, _, _ | R, _)         
     ------------------------------------- :: Nop
     upriv, C, F, M, I, S, n@L -- epsilon -> upriv, C, F, M, I, S, n+1@R

     I(n) = Nop
     C <> C' = (Nop | L | _, _, _ | _, _)
     ------------------------------------- :: Nop_Fail
     upriv, C, F, M, I, S, n@L -- epsilon -> priv, C', F, M, I, [(pc, upriv) ;; S], 0@bot

     I(n) = Output
     C = (Output | L | K, _, _| R1, R2)         
     -------------------------------------------------------- :: Output
     upriv, C, F, M, I, [n@K; S], n@L -- n@R2 -> upriv, C, F, M, I, S, n+1@R1

    % % pointer offsetting won't be a binop, now stricter on the input values
    % % they must be integers
    %  I(pc) = BinOp o
    % -------------------------------------------------------- :: Step_BinOp
    %  M, I, [n1@L1; n1@L2; S], pc -- epsilon -> M, I, [(n1 o n2)@(L1\/L2); S], pc+1

    %  I(pc) = Push n
    %  -------------------------------------------------------- :: Step_Push
    %  M, I, S, pc -- epsilon -> M, I, [n @ bot; S], pc+1

    %  I(pc) = Load   quad    read M p = a
    %  -------------------------------------------------------- :: Step_Load
    %  M, I, [p@K; S], pc -- epsilon -> M, I, [a \/ K; S], pc+1

    %  I(pc) = Store    quad    read M p = n@L
    %  K \/ labOf(pc) <= L   quad   store M p (a \/ K \/ labOf(pc)) = M'
    %  -------------------------------------------------------- :: Step_Store
    %  M, I, [p@K; a; S], pc -- epsilon -> M', I, S, pc+1

    %  I(pc) = Jump
    %   -------------------------------------------------------- :: Step_Jump
    %  M, I, [pc'; S], pc -- epsilon -> M, I, S, pc' \/ labOf(pc)
    
    %  I(pc) = BNZ k  quad   m <> 0 
    %  -------------------------------------------------------- :: Step_BNZ_Yes
    %  M, I, [m@K; S], n@L -- epsilon -> M, I, S, (n+k)@L\/K
    
    %  I(pc) = BNZ k quad   m = 0 
    %  -------------------------------------------------------- :: Step_BNZ_No
    %  M, I, [m@K; S], n@L -- epsilon -> M, I, S, (n+1)@L\/ K

    %  I(pc) = Call
    %  -------------------------------------------------------- :: Step_Call
    %  M, I, [ pc' ; a ; S], pc -- epsilon -> M, I, [a; pc+1 ;; S], pc'\/labOf(pc)

    %  I(pc) = Ret
    %  -------------------------------------------------------- :: Step_Ret
    %  M, I, [a ; pc' ;; S], pc -- epsilon -> M, I, [a\/labOf(pc) ; S], pc'

     % I(pc) = Pop
     % -------------------------------------------------------- :: Step_Pop
     % M, I, [a; S], pc -- espilon -> M, I, S, pc+1

     % I(pc) = Swap
     % -------------------------------------------------------- :: Step_Swap
     % M, I, [a1; a2; S], pc -- espilon -> M, I, [a2; a1; S], pc+1

     % I(pc) = Ret
     % -------------------------------------------------------- :: Step_Ret_Pop
     % M, I, [a; a'; S], pc --epsilon -> M, I, [a; S], pc

     % M(pc) = Dup
     % -------------------------------------------------------- :: Step_Dup
     % M, [a; S], pc, T --> M, [a;a;S], pc+1, T
    


