
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Metavariable conventions

metavar o {{tex \mathord{\circ} }} ::=           {{com binary ops}}

metavar F {{tex \phi }} ::=      {{com tmu fault handler }}

metavar I {{tex \iota }} ::=      {{com instruction memory}}

metavar M {{tex \mu }} ::=      {{com memory}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

n, m, p, v :: 'n_' ::=                                {{com Integers}}
  | 0                       :: :: Zzro
  | 1                       :: :: Zone
  | n1 + n2                 :: :: ZPlus
  | n1 o n2                 :: :: ZBinOp  
  | ( n1 = n2 ) ? n3 : n4   :: :: ZIf  
  | ( n )                   :: S :: ZParen
  
b :: 'b_' ::=                                   {{com Privileged bit }}
  | upriv                   :: :: PbitOff  {{com user mode }}
  | priv                    :: :: PbitOn   {{com kernel mode  }}

T {{tex \mathtt{T} }}, 
N {{tex \mathtt{N} }}, 
K {{tex \mathtt{K} }}, 
R {{tex \mathtt{R} }}:: 'T_' ::=                 {{com Tags }}
  | bot                     :: :: Tbot      {{com bottom tag}}
  | _                       :: :: Tirrev    {{com irrelevant tag}}

a, pc :: 'a_' ::=                       {{com Atoms}}
  | n @ T                   :: :: ValAtom {{com atom = integers value plus tag}}
  | a + 1                   :: :: ANext   {{com increment offset part of code pointer }}
  | ( a )                   :: S :: AParen

instr :: 'instr_' ::=                              {{com Instructions}}
  | Nop                     :: :: iNop
  | Push n                  :: :: iPush    {{com push constant integer}}
  | Pop                     :: :: iPop
  | Dup                     :: :: iDup
  | BinOp o                 :: :: iBinOp   {{com binary op, returning integer}}
  | Jump                    :: :: iJump
  | BNZ n                   :: :: iBNZ     {{com conditional relative jump}}
  | Call                    :: :: iBCall
  | Ret                     :: :: iBRet
  | Load                    :: :: iLoad    
  | Store                   :: :: iStore
  | Output                  :: :: iOutput  {{com output the top of the stack, tainted with pc}}
  | Halt                    :: :: iHalt

opcode :: 'opcode_' ::=                              {{com Opcodes }}
  | nop                     :: :: oNop
  | push                    :: :: oPush
  | pop                     :: :: oPop
  | dup                     :: :: oDup
  | binop                   :: :: oBinOp   
  | jump                    :: :: oJump
  | bnz                     :: :: oBNZ     
  | call                    :: :: oBCall
  | ret                     :: :: oBRet
  | load                    :: :: oLoad    
  | str                     :: :: oStore
  | out                     :: :: oOutput  
  | opinvalid               :: :: oInvalid

e :: 'e_' ::=                              {{com Events}}
  | epsilon                 :: :: epsilon {{com no event }}
  | n @ T                  :: :: intE  {{com observable value event }}
  | ( e )                   :: S :: eParen   

S {{tex \sigma }} :: 'S_' ::=                     {{com Stack}}
  | Smty                    :: :: Smty     {{com empty stack}}
  | a ; S                   :: :: Sdcons   {{com stack atom cons}}
  | ( pc , b ) ;; S         :: :: Srcons   {{com stack frame marker cons (with return pc and priv bit )}}
  | [ S ]                   :: :: SParen

C {{tex \kappa }} :: 'C_' ::=    {{com TMU Caches = Opcode + 5-tuple of tags }}
  | ( opcode | T1 | T2 , T3 , T4 | T5 , T6 ) :: :: Cache {{com the whole cache}}
                  {{tex 
                    \begin{array}{|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}||@{\;}l@{\;}|@{\;}l@{\;}|}
                       \hline  
                          [[opcode]] & [[T1]] & [[T2]] & [[T3]] & [[T4]] & [[T5]] & [[T6]] \\ 
                       \hline
                       \end{array}
                     }}                  
   | [ ki , ko ]  :: :: CacheInOut   {{com  tmu cache inputs and outputs parts }}
                  {{tex [ [[ki]] , [[ko]] ] }}            

ki {{tex {\kappa_i} }},
kj {{tex {\kappa_j} }} :: 'ki_' ::= {{com  tmu cache input part }}
   | ( opcode | T1 | T2 , T3 , T4 ) :: :: CacheIn {{tex 
                    \begin{array}{|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|}
                       \hline  
                          [[opcode]] & [[T1]] & [[T2]] & [[T3]] & [[T4]] \\
                       \hline
                       \end{array}
                     }}

ko {{tex \kappa_o }} :: 'ko_' ::= {{com  tmu cache output part }}
   | ( T5 , T6 ) :: :: CacheOut {{tex 
                    \begin{array}{|@{\;}l@{\;}|@{\;}l@{\;}|}
                    \hline
                          [[T5]] & [[T6]] \\
                    \hline
                       \end{array}
                    }}
   |  kbot :: :: CacheOutDft 

kbot {{tex \kappa_{\scriptstyle \bot} }} :: ''  ::= {{com default output part of cache }}
   | ( bot , bot )  :: :: BotBot {{tex 
                   \begin{array}{|@{\;}l@{\;}|@{\;}l@{\;}|}
                   \hline
                          [[bot]] & [[bot]] \\
                   \hline
                    \end{array}
                    }}

   
formula :: formula_ ::=  
 | judgement                :: :: judgement
 | I ( n ) = instr         :: :: instr_lookup  {{com instruction lookup }}
 | F ( n ) = instr         :: :: instr_lookup_priv  {{com fault handler instruction lookup }}
 | read M p = a             :: :: load          {{com read from data memory }}
 | read C p = a             :: :: load_priv          {{com read from cache }}
 | store M p a = M'         :: :: store         {{com memory store of atom }}
 | store C p a = C'         :: :: store_priv         {{com cache write of atom }}
 | n1 = n2                  :: :: eq_int

 | C1 ~ C2                  :: :: cache_eq         {{com cache hit (equality of caches) }}
 
 | ki1 ~/~ ki2 ~ ki3        :: :: cache_neq         {{com cache input miss and update }}

 | formula1 quad formula2   :: :: savingspace

terminals :: 'terminals_' ::=
  | ==>                 :: :: eval       {{tex \Longrightarrow }}
  | quad                :: :: savespace  {{tex \qquad }}
  | \/                  :: :: join       {{tex \mathord{\vee} }}
  | <>                  :: :: noteq      {{tex \neq }}
  | ~                   :: :: match      {{tex = }}
  | ~/~                 :: :: dmatch     {{tex \not= }}
  | @                   :: :: attag    {{tex {\scriptstyle \mathord{@} } }}
  | ;;                  :: :: semisemi   {{tex \mathord{;\!;} }}
  | +                   :: :: plus       {{tex \mathord{+} }}
  | +1                  :: :: plusplus   {{tex {\scriptstyle \mathord{+\!+} } }}
  | |->                 :: :: mapsto     {{tex {\scriptstyle \mathord{\mapsto} } }}
  | forall              :: :: forall     {{tex \forall }}
  | <=                  :: :: le         {{tex \le }}
  | Smty                :: :: Smty       {{tex \text{\sf mty} }}
  | bot                 :: :: bot        {{tex \bot }}
  | <|                  :: :: lcp        {{tex \langle }}
  | |>                  :: :: rcp        {{tex \rangle }}

  | Call                :: :: Call      {{tex \text{\sf Call} }} 
  | Output              :: :: Output    {{tex \text{\sf Output} }}
  | Invalid             :: :: Invalid   {{tex \text{\sf Invalid} }}
  | Load                :: :: Load       {{tex \text{\sf Load} }} 
  | Store               :: :: Store      {{tex \text{\sf Store} }} 
  | Nop                 :: :: Nop        {{tex \text{\sf Nop} }}
  | Push                :: :: Push       {{tex \text{\sf Push} }} 
  | Pop                 :: :: Pop        {{tex \text{\sf Pop} }} 
  | Dup                 :: :: Dup        {{tex \text{\sf Dup} }} 
  | BinOp               :: :: BinOp      {{tex \text{\sf BinOp} }}
  | Jump                :: :: Jump       {{tex \text{\sf Jump} }} 
  | BNZ                 :: :: BNZ        {{tex \text{\sf BNZ} }} 
  | Ret                 :: :: Ret        {{tex \text{\sf Ret} }} 
  | Halt                :: :: Halt       {{tex \text{\sf Halt} }} 

  | call                :: :: oCall      {{tex \text{\sf Call} }} 
  | out                 :: :: oOutput    {{tex \text{\sf Output} }}
  | load                :: :: oLoad       {{tex \text{\sf Load} }} 
  | str                 :: :: oStore      {{tex \text{\sf Store} }} 
  | nop                 :: :: oNop        {{tex \text{\sf Nop} }}
  | push                :: :: oPush       {{tex \text{\sf Push} }} 
  | pop                 :: :: oPop        {{tex \text{\sf Pop} }} 
  | dup                 :: :: oDup        {{tex \text{\sf Dup} }} 
  | binop               :: :: oBinOp      {{tex \text{\sf BinOp} }}
  | jump                :: :: oJump       {{tex \text{\sf Jump} }} 
  | bnz                 :: :: oBNZ        {{tex \text{\sf BNZ} }} 
  | ret                 :: :: oRet        {{tex \text{\sf Ret} }} 

  | epsilon             :: :: eE0       {{tex \varepsilon }} 
  | upriv               :: :: upriv     {{tex \text{\sf u} }} 
  | priv                :: :: priv      {{tex \text{\sf k} }} 

defns
SmallStepEval :: '' ::=

  defn 
  b1 , C1 , F1 , M1 , I1 , S1 , pc1 -- e -> b2 , C2 , F2 , M2 , I2 , S2 , pc2  :: :: step :: '' 
  {{tex \def\arraystretch{.7}
  \setlength\arraycolsep{2pt} \begin{array}{lclrlc}
  [[b1]] & [[C1]] & [[M1]] & [[S1]] & [[pc1]] & \xrightarrow{[[e]]} \\
  [[b2]] & [[C2]] & [[M2]] & [[S2]] & [[pc2]]
  \end{array} }} by

     I(n) = Nop
     C ~ (nop | T | bot, bot, bot | R, bot)         
     ------------------------------------- :: Nop
     upriv, C, F, M, I, S, n@T -- epsilon -> upriv, C, F, M, I, S, n+1@R

     I(n) = Nop
     ki ~/~ (nop | T | bot, bot, bot) ~ kj
     ------------------------------------- :: Nop_F
     upriv, [ki,ko], F, M, I, S, n@T -- epsilon -> priv, [kj,kbot], F, M, I, [(n@T, upriv) ;; S], 0@bot

     F(n) = Nop
     ------------------------------------- :: Nop_P
     priv, C, F, M, I, S, n@T -- epsilon -> priv, C, F, M, I, S, n+1@T

     I(n) = Output
     C ~ (out | T | N, bot, bot| R1, R2)         
     -------------------------------------------------------- :: Out
     upriv, C, F, M, I, [v@N; S], n@T -- v@R2 -> upriv, C, F, M, I, S, n+1@R1

     I(n) = Output
     ki ~/~ (out | T | N, bot, bot) ~ kj
     -------------------------------------------------------- :: Out_F
     upriv, [ki,ko], F, M, I, [v@N; S], n@T -- epsilon -> priv, [kj,kbot], F, M, I, [(n@T,upriv) ;; v@N ; S], 0@bot

     I(n) = BinOp o
     C ~ (binop | T | T1, T2, bot| R1, R2) 
    -------------------------------------------------------- :: BOp
     upriv, C, F, M, I, [n1@T1; n2@T2; S], n@T -- epsilon -> upriv, C, F, M, I, [(n1 o n2)@R2; S], n+1@R1

     I(n) = BinOp o
     ki ~/~ ( binop | T | T1, T2, bot) ~ kj
    -------------------------------------------------------- :: BOp_F
     upriv, [ki,ko], F, M, I, [n1@T1; n1@T2; S], n@T -- epsilon -> priv, [kj,kbot], F, M, I, [ (n@T,upriv);; n1@T1; n1@T2 ; S], 0@bot

     F(n) = BinOp o
    -------------------------------------------------------- :: BOp_P
     priv, C, F, M, I, [n1@T1; n1@T2; S], n@T -- epsilon -> priv, C, F, M, I, [(n1 o n2)@T; S], n+1@T
     
     I(n) = Push m
     C ~ ( push | T | bot, bot, bot| R1, R2)
     -------------------------------------------------------- :: Psh
     upriv, C, F, M, I, S, n@T -- epsilon -> upriv, C, F, M, I, [m @ R2; S], n+1@R1

     I(n) = Push m
     ki ~/~ ( push | T | bot, bot, bot) ~ kj
     -------------------------------------------------------- :: Psh_F
     upriv, [ki,ko], F, M, I, S, n@T -- epsilon -> priv, [kj,kbot], F, M, I, [(n@T,upriv) ;; S], 0@bot

     F(n) = Push m
     -------------------------------------------------------- :: Psh_P
     priv, C, F, M, I, S, n@T -- epsilon -> priv, C, F, M, I, [m @ bot; S], n+1@T

     I(n) = Load
     read M p = v@N
     C ~ ( load | T | K, N, bot| R1, R2)
     -------------------------------------------------------- :: Ld
     upriv, C, F, M, I, [p@K; S], n@T -- epsilon -> upriv, C, F, M, I, [v@R2; S], n+1@R1

     I(n) = Load
     read M p = v@N
     ki ~/~ ( load | T | K, N, bot) ~ kj
     -------------------------------------------------------- :: Ld_F
     upriv, [ki,ko], F, M, I, [p@K; S], n@T -- epsilon -> priv, [kj,kbot], F, M, I, [(n@T,upriv) ;; p@K; S], 0@bot

     F(n) = Load  
     read C p = v@N
     -------------------------------------------------------- :: Ld_P
     priv, C, F, M, I, [p@K; S], n@T -- epsilon -> priv, C, F, M, I, [v@N; S], n+1@T

     I(n) = Store    quad    read M p = m@N2
     C ~ ( str | T | K, N1, N2| R1, R2) 
     store M p (v@R2) = M'
     -------------------------------------------------------- :: St
     upriv, C, F, M, I, [p@K; v@N1; S], n@T -- epsilon -> upriv, C, F, M', I, S, n+1@R1

     I(n) = Store    quad    read M p = m@N2
     ki ~/~ ( str | T | K, N1, N2)  ~ kj
     -------------------------------------------------------- :: St_F
     upriv, [ki,ko], F, M, I, [p@K; v@N1; S], n@T -- epsilon -> priv, [kj,kbot], F, M, I, [ (n@T,upriv) ;; p@K; v@N1; S], 0@bot 

     F(n) = Store    
     store C p (v@N) = C'
     -------------------------------------------------------- :: St_P
     priv, C, F, M, I, [p@K; v@N; S], n@T -- epsilon -> priv, C', F, M, I, S, n+1@T

     I(n) = Jump
     C ~ ( jump | T | K, bot, bot| R1, bot)
      -------------------------------------------------------- :: Jmp
     upriv, C, F, M, I, [v@K; S], n@T -- epsilon -> upriv, C, F, M, I, S, v@R1

     I(n) = Jump
     ki ~/~ ( jump | T | K, bot, bot) ~ kj
      -------------------------------------------------------- :: Jmp_F
     upriv, [ki,ko], F, M, I, [v@K; S], n@T -- epsilon -> priv, [kj,kbot], F, M, I, [ (n@T,upriv) ;; v@K ; S], 0@bot

     F(n) = Jump
      -------------------------------------------------------- :: Jmp_P
     priv, C, F, M, I, [v@K; S], n@T -- epsilon -> priv, C, F, M, I, S, v@T
    
     I(n) = BNZ m
     C ~ ( bnz | T | K, bot, bot| R1, bot)
     n' = n+ (v = 0)? 1 : m  
     -------------------------------------------------------- :: Bnz
     upriv, C, F, M, I, [v@K; S], n@T -- epsilon -> upriv, C, F, M, I, S, n'@R1
    
     I(n) = BNZ m
     ki ~/~ ( bnz | T | K, bot, bot) ~ kj
     -------------------------------------------------------- :: Bnz_F
     upriv, [ki,ko], F, M, I, [v@K; S], n@T -- epsilon -> priv, [kj,kbot], F, M, I, [ (n@T,upriv) ;; v@K ; S], 0@bot

     F(n) = BNZ m
     n' = n+ (v = 0)? 1 : m  
     -------------------------------------------------------- :: Bnz_P
     priv, C, F, M, I, [v@K; S], n@T -- epsilon -> priv, C, F, M, I, S, n'@T

     I(n) = Call
     C ~ ( call | T | K, bot, bot| R1, R2)
     -------------------------------------------------------- :: Cll
     upriv, C, F, M, I, [ p@K ; a ; S], n@T -- epsilon -> upriv, C, F, M, I, [a; (n+1@R2,upriv) ;; S], p@R1

     I(n) = Call
     ki ~/~ ( call | T | K, bot, bot) ~ kj
     -------------------------------------------------------- :: Cll_F
     upriv, [ki,ko], F, M, I, [ p@K ; a ; S], n@T -- epsilon -> priv, [kj,kbot], F, M, I, [ (n@T,upriv) ;; p@K ; a ; S], 0@bot

     F(n) = Call
     -------------------------------------------------------- :: Cll_P
     priv, C, F, M, I, [ p@K ; v@N ; S], n@T -- epsilon -> priv, C, F, M, I, [v@N; (n+1@T,priv) ;; S], p@K

     I(n) = Ret
     C ~ ( ret | T | N, K, bot| R1, R2)
     -------------------------------------------------------- :: Ret
     upriv, C, F, M, I, [v@N ; (p@K,b) ;; S], n@T -- epsilon -> b, C, F, M, I, [v@R2 ; S], p@R1

     I(n) = Ret
     ki ~/~ ( ret | T | N, K, bot) ~ kj
     -------------------------------------------------------- :: Ret_F
     upriv, [ki,ko], F, M, I, [v@N ; (p@K,b) ;; S], n@T -- epsilon -> priv, [kj,kbot], F, M, I, [ (n@T,upriv) ;; v@N ; (p@K,b) ;; S], 0@bot

     F(n) = Ret
     -------------------------------------------------------- :: Ret_P
     priv, C, F, M, I, [(p@K,b) ;; S], n@T -- epsilon -> b, C, F, M, I, S, p@K

     % I(pc) = Pop
     % -------------------------------------------------------- :: Pop
     % M, I, [a; S], pc -- espilon -> M, I, S, pc+1

     % I(pc) = Swap
     % -------------------------------------------------------- :: Swap
     % M, I, [a1; a2; S], pc -- espilon -> M, I, [a2; a1; S], pc+1

     % I(pc) = Ret
     % -------------------------------------------------------- :: Ret_Pop
     % M, I, [a; a'; S], pc --epsilon -> M, I, [a; S], pc

     % M(pc) = Dup
     % -------------------------------------------------------- :: Dup
     % M, [a; S], pc, T --> M, [a;a;S], pc+1, T
    


