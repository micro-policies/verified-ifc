
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Metavariable conventions

metavar o {{tex \mathord{\circ} }} ::=           {{com binary ops}}

metavar F {{tex \phi }} ::=      {{com tmu fault handler }}

metavar I {{tex \iota }} ::=      {{com instruction memory}}

metavar M {{tex \mu }} ::=      {{com memory}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

n, m, k, p, v :: 'n_' ::=                                {{com Integers}}
  | 0                       :: :: Zzro
  | 1                       :: :: Zone
  | n1 + n2                 :: :: ZPlus
  | n1 o n2                 :: :: ZBinOp  
  | ( n1 = n2 ) ? n3 : n4      :: :: ZIf  
  | ( n )                   :: S :: ZParen

b :: 'b_' ::=                         {{com Privileged bit }}
  | upriv                       :: :: PbitOff {{com ON }}
  | priv                       :: :: PbitOn  {{com OFF }}

L {{tex \mathtt{L} }}, N {{tex \mathtt{N} }}, K {{tex \mathtt{K} }}, R {{tex \mathtt{R} }}:: 'L_' ::=                  {{com Labels }}
  | bot                     :: :: Lbot      {{com bottom label}}
  | _                       :: :: Lirrev      {{com irrelevant label}}
  | ( L )                   :: S :: LParen

a, pc :: 'a_' ::=                       {{com Atoms}}
  | n @ L                   :: :: ValAtom {{com atom = integers value plus label}}
  | a + 1                   :: :: ANext   {{com increment offset part of code pointer }}
  | ( a )                   :: S :: AParen

instr :: 'instr_' ::=                              {{com Instructions}}
  | Nop                     :: :: iNop
  | Push n                  :: :: iPush    {{com push constant integer}}
  | Pop                     :: :: iPop
  | Dup                     :: :: iDup
  | BinOp o                 :: :: iBinOp   {{com binary op, returning integer}}
  | Jump                    :: :: iJump
  | BNZ n                   :: :: iBNZ     {{com conditional relative jump}}
  | Call                    :: :: iBCall
  | Ret                     :: :: iBRet
  | Load                    :: :: iLoad    
  | Store                   :: :: iStore
  | Output                  :: :: iOutput  {{com output the top of the stack, tainted with pc}}
  | Halt                    :: :: iHalt

opcode :: 'opcode_' ::=                              {{com Opcodes - instructions with no "arguments" }}
  | nop                     :: :: oNop
  | push                    :: :: oPush
  | pop                     :: :: oPop
  | dup                     :: :: oDup
  | binop                   :: :: oBinOp   
  | jump                    :: :: oJump
  | bnz                     :: :: oBNZ     
  | call                    :: :: oBCall
  | ret                     :: :: oBRet
  | load                    :: :: oLoad    
  | str                     :: :: oStore
  | out                     :: :: oOutput  


e :: 'e_' ::=                              {{com Events}}
  | epsilon                 :: :: epsilon {{com no event }}
  | n @ L                  :: :: intE  {{com observable value event }}
  | ( e )                   :: S :: eParen   

S {{tex \sigma }} :: 'S_' ::=                     {{com Stack}}
  | Smty                    :: :: Smty     {{com empty stack}}
  | a ; S                   :: :: Sdcons   {{com stack atom cons}}
  | ( pc , b ) ;; S         :: :: Srcons   {{com stack frame marker cons (with return pc and priv bit )}}
  | [ S ]                   :: :: SParen

C {{tex \kappa }} :: 'C_' ::=    {{com TMU Caches = a 5-tuple of labels }}
  | ( opcode | L1 | L2 , L3 , L4 | L5 , L6 ) :: :: Cache {{tex 
  \begin{array}{|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}||@{\;}l@{\;}|@{\;}l@{\;}|}
        \hline
        [[opcode]] & [[L1]] & [[L2]] & [[L3]] & [[L4]] & [[L5]] & [[L6]] \\ 
        \hline
        \end{array}
   }} 
  
formula :: formula_ ::=  
 | judgement                :: :: judgement
 | I ( n ) = instr         :: :: instr_lookup  {{com instruction lookup }}
 | F ( n ) = instr         :: :: instr_lookup_priv  {{com fault handler instruction lookup }}
 | read M p = a             :: :: load          {{com read from data memory }}
 | read C p = a             :: :: load_priv          {{com read from cache }}
 | store M p a = M'         :: :: store         {{com memory store of atom }}
 | store C p a = C'         :: :: store_priv         {{com cache write of atom }}

 | n1 <> n2                 :: :: not_eq_int
 | n1 = n2                  :: :: eq_int
 | M1 = M2                  :: :: eq_mem
 | p1 <> p2                 :: :: not_eq_pntr
 | p1 = p2                  :: :: eq_pntr
 | a1 = a2                  :: :: eq_atm
 | L1 = L2                  :: :: labelEq

 | C1 ~ C2                  :: :: cache_eq         {{com cache hit (equality of caches) }}
 
 | C1 ~/~ C2 ~ C3            :: :: cache_neq         {{com cache miss and update }}

 | formula1 quad formula2   :: :: savingspace

terminals :: 'terminals_' ::=
  | ==>                 :: :: eval       {{tex \Longrightarrow }}
  | quad                :: :: savespace  {{tex \qquad }}
  | \/                  :: :: join       {{tex \mathord{\vee} }}
  | <>                  :: :: noteq      {{tex \neq }}
  | ~                   :: :: match      {{tex \sim }}
  | ~/~                 :: :: dmatch     {{tex \not\sim }}
  | @                   :: :: atlabel    {{tex {\scriptstyle \mathord{@} } }}
  | ;;                  :: :: semisemi   {{tex \mathord{;\!;} }}
  | +                   :: :: plus       {{tex \mathord{+} }}
  | +1                  :: :: plusplus   {{tex {\scriptstyle \mathord{+\!+} } }}
  | |->                 :: :: mapsto     {{tex {\scriptstyle \mathord{\mapsto} } }}
  | forall              :: :: forall     {{tex \forall }}
  | <=                  :: :: le         {{tex \le }}
  | Smty                :: :: Smty       {{tex \text{\sf mty} }}
  | bot                 :: :: bot        {{tex \bot }}
  | <|                  :: :: lcp        {{tex \langle }}
  | |>                  :: :: rcp        {{tex \rangle }}

  | Call                :: :: Call      {{tex \text{\sf Call} }} 
  | Output              :: :: Output    {{tex \text{\sf Output} }}
  | Load                :: :: Load       {{tex \text{\sf Load} }} 
  | Store               :: :: Store      {{tex \text{\sf Store} }} 
  | Nop                 :: :: Nop        {{tex \text{\sf Nop} }}
  | Push                :: :: Push       {{tex \text{\sf Push} }} 
  | Pop                 :: :: Pop        {{tex \text{\sf Pop} }} 
  | Dup                 :: :: Dup        {{tex \text{\sf Dup} }} 
  | BinOp               :: :: BinOp      {{tex \text{\sf BinOp} }}
  | Jump                :: :: Jump       {{tex \text{\sf Jump} }} 
  | BNZ                 :: :: BNZ        {{tex \text{\sf BNZ} }} 
  | Ret                 :: :: Ret        {{tex \text{\sf Ret} }} 
  | Halt                :: :: Halt       {{tex \text{\sf Halt} }} 

  | call                :: :: oCall      {{tex \text{\sf Call} }} 
  | out                 :: :: oOutput    {{tex \text{\sf Output} }}
  | load                :: :: oLoad       {{tex \text{\sf Load} }} 
  | str                 :: :: oStore      {{tex \text{\sf Store} }} 
  | nop                 :: :: oNop        {{tex \text{\sf Nop} }}
  | push                :: :: oPush       {{tex \text{\sf Push} }} 
  | pop                 :: :: oPop        {{tex \text{\sf Pop} }} 
  | dup                 :: :: oDup        {{tex \text{\sf Dup} }} 
  | binop               :: :: oBinOp      {{tex \text{\sf BinOp} }}
  | jump                :: :: oJump       {{tex \text{\sf Jump} }} 
  | bnz                 :: :: oBNZ        {{tex \text{\sf BNZ} }} 
  | ret                 :: :: oRet        {{tex \text{\sf Ret} }} 

  | epsilon             :: :: eE0       {{tex \varepsilon }} 
  | upriv               :: :: upriv     {{tex 0 }} 
  | priv                :: :: priv      {{tex 1 }} 

defns
SmallStepEval :: '' ::=

  defn 
  b1 , C1 , F1 , M1 , I1 , S1 , pc1 -- e -> b2 , C2 , F2 , M2 , I2 , S2 , pc2  :: :: step :: '' 
  {{tex \def\arraystretch{.7}
  \setlength\arraycolsep{2pt} \begin{array}{lllrlc}
  [[b1]] & [[C1]] & [[M1]] & [[S1]] & [[pc1]] & \xrightarrow{[[e]]}   \\
  [[b2]] & [[C2]] & [[M2]] & [[S2]] & [[pc2]]
  \end{array} }} by

     I(n) = Nop
     C ~ (nop | L | _, _, _ | R, _)         
     ------------------------------------- :: Nop
     upriv, C, F, M, I, S, n@L -- epsilon -> upriv, C, F, M, I, S, n+1@R

     I(n) = Nop
     C ~/~ (nop | L | _, _, _ | _, _) ~ C'
     ------------------------------------- :: Nop_F
     upriv, C, F, M, I, S, n@L -- epsilon -> priv, C', F, M, I, [(n@L, upriv) ;; S], 0@bot

     F(n) = Nop
     ------------------------------------- :: Nop_P
     priv, C, F, M, I, S, n@L -- epsilon -> priv, C, F, M, I, S, n+1@L


     I(n) = Output
     C ~ (out | L | K, _, _| R1, R2)         
     -------------------------------------------------------- :: Out
     upriv, C, F, M, I, [n@K; S], n@L -- n@R2 -> upriv, C, F, M, I, S, n+1@R1

     I(n) = Output
     C ~/~ C' ~ (out | L | K, _, _| _, _)         
     -------------------------------------------------------- :: Out_F
     upriv, C, F, M, I, [n@K; S], n@L -- epsilon -> priv, C, F, M, I, [(n@L,upriv) ;; n@K ; S], 0@bot

     I(n) = BinOp o
     C ~ (binop | L | L1, L2, _| R1, R2) 
    -------------------------------------------------------- :: BOp
     upriv, C, F, M, I, [n1@L1; n1@L2; S], n@L -- epsilon -> upriv, C, F, M, I, [(n1 o n2)@R2; S], n+1@R1

     I(n) = BinOp o
     C ~/~ C' ~ ( binop | L | L1, L2, _| _, _)
    -------------------------------------------------------- :: BOp_F
     upriv, C, F, M, I, [n1@L1; n1@L2; S], n@L -- epsilon -> priv, C', F, M, I, [ (n@L,upriv);; n1@L1; n1@L2 ; S], 0@bot

     F(n) = BinOp o
    -------------------------------------------------------- :: BOp_P
     priv, C, F, M, I, [n1@L1; n1@L2; S], n@L -- epsilon -> priv, C, F, M, I, [(n1 o n2)@L; S], n+1@L
     
     I(n) = Push k
     C ~ ( push | L | _, _, _| R1, R2)
     -------------------------------------------------------- :: Psh
     upriv, C, F, M, I, S, n@L -- epsilon -> upriv, C, F, M, I, [k @ R2; S], n+1@R1

     I(n) = Push k
     C ~/~ C' ~ ( push | L | _, _, _| _, _)
     -------------------------------------------------------- :: Psh_F
     upriv, C, F, M, I, S, n@L -- epsilon -> priv, C', F, M, I, [(n@L,upriv) ;; S], 0@bot

     F(n) = Push k
     -------------------------------------------------------- :: Psh_P
     priv, C, F, M, I, S, n@L -- epsilon -> priv, C, F, M, I, [k @ bot; S], n+1@L

     I(n) = Load
     read M p = k@N
     C ~ ( load | L | K, N, _| R1, R2)
     -------------------------------------------------------- :: Ld
     upriv, C, F, M, I, [p@K; S], n@L -- epsilon -> upriv, C, F, M, I, [k@R2; S], n+1@R1

     I(n) = Load
     read M p = k@N
     C ~/~ C' ~ ( load | L | K, N, _| _, _)
     -------------------------------------------------------- :: Ld_F
     upriv, C, F, M, I, [p@K; S], n@L -- epsilon -> priv, C', F, M, I, [(n@L,upriv) ;; p@K; S], 0@bot

     F(n) = Load  
     read C p = k@N
     -------------------------------------------------------- :: Ld_P
     priv, C, F, M, I, [p@K; S], n@L -- epsilon -> priv, C, F, M, I, [k@N; S], n+1@L

     I(n) = Store    quad    read M p = k@N2
     C ~ ( str | L | K, N1, N2| R1, R2) 
     store M p (v@R2) = M'
     -------------------------------------------------------- :: St
     upriv, C, F, M, I, [p@K; v@N1; S], n@L -- epsilon -> upriv, C, F, M', I, S, n+1@R1

     I(n) = Store    quad    read M p = k@N2
     C ~/~ C' ~ ( str | L | K, N1, N2| _, _)    
     -------------------------------------------------------- :: St_F
     upriv, C, F, M, I, [p@K; v@N1; S], n@L -- epsilon -> priv, C', F, M, I, [ (n@L,upriv) ;; p@K; v@N1; S], 0@bot 

     F(n) = Store    
     store C p (v@N) = C'
     -------------------------------------------------------- :: St_P
     priv, C, F, M, I, [p@K; v@N; S], n@L -- epsilon -> priv, C', F, M, I, S, n+1@L

     I(n) = Jump
     C ~ ( jump | L | K, _, _| R1, _)
      -------------------------------------------------------- :: Jmp
     upriv, C, F, M, I, [k@K; S], n@L -- epsilon -> upriv, C, F, M, I, S, k@R1

     I(n) = Jump
     C ~/~ C' ~ ( jump | L | K, _, _| _, _)
      -------------------------------------------------------- :: Jmp_F
     upriv, C, F, M, I, [k@K; S], n@L -- epsilon -> priv, C', F, M, I, [ (n@L,upriv) ;; k@K ; S], 0@bot

     F(n) = Jump
      -------------------------------------------------------- :: Jmp_P
     priv, C, F, M, I, [k@K; S], n@L -- epsilon -> priv, C, F, M, I, S, k@L
    
     I(n) = BNZ k
     C ~ ( bnz | L | K, _, _| R1, _)
     n' = n+ (m = 0)? 1 : k  
     -------------------------------------------------------- :: Bnz
     upriv, C, F, M, I, [m@K; S], n@L -- epsilon -> upriv, C, F, M, I, S, n'@R1
    
     I(n) = BNZ k
     C ~/~ C' ~ ( bnz | L | K, _, _| _, _)
     -------------------------------------------------------- :: Bnz_F
     upriv, C, F, M, I, [m@K; S], n@L -- epsilon -> priv, C', F, M, I, [ (n@L,upriv) ;; m@K ; S], 0@bot

     F(n) = BNZ k
     n' = n+ (m = 0)? 1 : k  
     -------------------------------------------------------- :: Bnz_P
     upriv, C, F, M, I, [m@K; S], n@L -- epsilon -> priv, C, F, M, I, S, n'@L

     I(n) = Call
     C ~ ( call | L | K, N, _| R1, R2)
     -------------------------------------------------------- :: Cll
     upriv, C, F, M, I, [ p@K ; v@N ; S], n@L -- epsilon -> upriv, C, F, M, I, [v@N; (n+1@R2,upriv) ;; S], p@R1

     I(n) = Call
     C ~/~ C' ~ ( call | L | K, N, _| _, _)
     -------------------------------------------------------- :: Cll_F
     upriv, C, F, M, I, [ p@K ; v@N ; S], n@L -- epsilon -> priv, C', F, M, I, [ (n@L,upriv) ;; p@K ; v@N ; S], 0@bot

     F(n) = Call
     -------------------------------------------------------- :: Cll_P
     priv, C, F, M, I, [ p@K ; v@N ; S], n@L -- epsilon -> priv, C, F, M, I, [v@N; (n+1@L,priv) ;; S], p@K

     I(n) = Ret
     C ~ ( ret | L | N, K, _| R1, R2)
     -------------------------------------------------------- :: Ret
     upriv, C, F, M, I, [v@N ; (p@K,b) ;; S], n@L -- epsilon -> b, C, F, M, I, [v@R2 ; S], p@R1

     I(n) = Ret
     C ~/~ C' ~ ( ret | L | N, K, _| _, _)
     -------------------------------------------------------- :: Ret_F
     upriv, C, F, M, I, [v@N ; (p@K,b) ;; S], n@L -- epsilon -> priv, C', F, M, I, [ (n@L,upriv) ;; v@N ; (p@K,b) ;; S], 0@bot

     F(n) = Ret
     -------------------------------------------------------- :: Ret_P
     priv, C, F, M, I, [(p@K,b) ;; S], n@L -- epsilon -> b, C, F, M, I, S, p@K

     % I(pc) = Pop
     % -------------------------------------------------------- :: Pop
     % M, I, [a; S], pc -- espilon -> M, I, S, pc+1

     % I(pc) = Swap
     % -------------------------------------------------------- :: Swap
     % M, I, [a1; a2; S], pc -- espilon -> M, I, [a2; a1; S], pc+1

     % I(pc) = Ret
     % -------------------------------------------------------- :: Ret_Pop
     % M, I, [a; a'; S], pc --epsilon -> M, I, [a; S], pc

     % M(pc) = Dup
     % -------------------------------------------------------- :: Dup
     % M, [a; S], pc, T --> M, [a;a;S], pc+1, T
    


