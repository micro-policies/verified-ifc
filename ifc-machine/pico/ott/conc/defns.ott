
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Metavariable conventions

metavar o {{tex \mathord{\circ} }} ::=           {{com binary ops}}

metavar F {{tex \phi }} ::=      {{com tmu fault handler }}

metavar I {{tex \iota }} ::=      {{com instruction memory}}

metavar M {{tex \mu }} ::=      {{com abstract memory}}

metavar cM {{tex \boldsymbol{\mu} }} ::=      {{com concrete memory}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

n, m, l, p :: 'n_' ::=                              {{com Integers}}
  | 0                       :: :: Zzro
  | 1                       :: :: Zone
  | n1 + n2                 :: :: ZPlus
  | n1 o n2                 :: :: ZBinOp  
  | ( n1 = n2 ) ? n3 : n4   :: :: ZIf  
  | ( n )                   :: S :: ZParen

priv {{tex \pi }} :: 'priv_' ::=                      {{com Privileged bit }}
  | upriv                   :: :: PbitOff  {{com user mode }}
  | kpriv                   :: :: PbitOn   {{com kernel mode  }}

T {{tex \mathtt{T} }}, 
R {{tex \mathtt{R} }}:: 'T_' ::=                 {{com Tags }}
  | Tbot                     :: :: Tbot      {{com default tag}}
  | _                       :: :: Tirrev    {{com irrelevant tag}}

ca {{tex \mathitbf{a} }}, cpc {{tex \mathitbf{pc} }} :: 'ca_' ::=    {{com Concrete Atoms}}
  | n @ T                   :: :: ValAtom {{com atom = integers value plus tag}}
  | ca + 1                  :: :: ANext   {{com increment offset part of code pointer }}
  | ( ca )                  :: S :: AParen

instr :: 'instr_' ::=                              {{com Instructions}}
  | Nop                     :: :: iNop
  | Push n                  :: :: iPush    {{com push constant integer}}
  | Pop                     :: :: iPop
  | Dup                     :: :: iDup
  | BinOp o                 :: :: iBinOp   {{com binary op, returning integer}}
  | Jump                    :: :: iJump
  | BNZ n                   :: :: iBNZ     {{com conditional relative jump}}
  | Call                    :: :: iBCall
  | Ret                     :: :: iBRet
  | Load                    :: :: iLoad    
  | Store                   :: :: iStore
  | Output                  :: :: iOutput  {{com output the top of the stack, tainted with pc}}
  | Halt                    :: :: iHalt

opcode :: 'opcode_' ::=                              {{com Opcodes }}
  | nop                     :: :: oNop
  | push                    :: :: oPush
  | pop                     :: :: oPop
  | dup                     :: :: oDup
  | binop                   :: :: oBinOp   
  | jump                    :: :: oJump
  | bnz                     :: :: oBNZ     
  | call                    :: :: oBCall
  | ret                     :: :: oBRet
  | load                    :: :: oLoad    
  | str                     :: :: oStore
  | out                     :: :: oOutput  
  | opinvalid               :: :: oInvalid

ce :: 'ce_' ::=                              {{com Events}}
  | cepsilon                 :: :: epsilon {{com no event }}
  | n @ T                  :: :: intE  {{com observable value event }}
  | ( ce )                   :: S :: eParen   

cS {{tex \boldsymbol{\sigma} }} :: 'cS_' ::=                     {{com Stack}}
  | cSmty                    :: :: cSmty     {{com empty stack}}
  | ca ; cS                  :: :: cSdcons   {{com stack atom cons}}
  | ( cpc , priv ) ;; cS     :: :: cSrcons   {{com stack frame marker cons (with return pc and priv bit )}}
  | [ cS ]                   :: :: cSParen

C {{tex \kappa }} :: 'C_' ::=    {{com TMU Caches = Opcode + 5-tuple of tags }}
  | ( opcode | T1 | T2 , T3 , T4 | T5 , T6 ) :: :: Cache {{com the whole cache}}
                  {{tex 
                    \begin{array}{|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}||@{\;}l@{\;}|@{\;}l@{\;}|}
                       \hline  
                          [[opcode]] & [[T1]] & [[T2]] & [[T3]] & [[T4]] & [[T5]] & [[T6]] \\ 
                       \hline
                       \end{array}
                     }}                  
   | [ ki , ko ]  :: :: CacheInOut   {{com  tmu cache inputs and outputs parts }}
                  {{tex [ [[ki]] , [[ko]] ] }}            

ki {{tex {\kappa_i} }},
kj {{tex {\kappa_j} }} :: 'ki_' ::= {{com  tmu cache input part }}
   | ( opcode | T1 | T2 , T3 , T4 ) :: :: CacheIn {{tex 
                    \begin{array}{|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|}
                       \hline  
                          [[opcode]] & [[T1]] & [[T2]] & [[T3]] & [[T4]] \\
                       \hline
                       \end{array}
                     }}

ko {{tex \kappa_o }} :: 'ko_' ::= {{com  tmu cache output part }}
   | ( T5 , T6 ) :: :: CacheOut {{tex 
                    \begin{array}{|@{\;}l@{\;}|@{\;}l@{\;}|}
                    \hline
                          [[T5]] & [[T6]] \\
                    \hline
                       \end{array}
                    }}
   |  kbot :: :: CacheOutDft 

kbot {{tex \kappa_{\_} }} :: ''  ::= {{com default output part of cache }}
   | ( _ , _ )  :: :: BotBot {{tex 
                   \begin{array}{|@{\;}l@{\;}|@{\;}l@{\;}|}
                   \hline
                          [[_]] & [[_]] \\
                   \hline
                    \end{array}
                    }}


formula :: formula_ ::=  
 | judgement                :: :: judgement
 | I ( n ) = instr         :: :: instr_lookup  {{com instruction lookup }}
 | F ( n ) = instr         :: :: instr_lookup_priv  {{com fault handler instruction lookup }}
 | cread cM p = ca             :: :: load          {{com read from data memory }}
 | read C p = ca             :: :: load_priv          {{com read from cache }}
 | cstore cM p ca = cM'         :: :: store         {{com memory store of atom }}
 | store C p ca = C'         :: :: store_priv         {{com cache write of atom }}
 | n1 = n2                  :: :: eq_int

 | C1 ~ C2                  :: :: cache_eq         {{com cache hit (equality of caches) }}
 
 | ki1 ~/~ ki2 ~ ki3        :: :: cache_neq         {{com cache input miss and update }}

 | formula1 quad formula2   :: :: savingspace

terminals :: 'terminals_' ::=
  | ==>                 :: :: eval       {{tex \Longrightarrow }}
  | quad                :: :: savespace  {{tex \qquad }}
  | \/                  :: :: join       {{tex \mathord{\vee} }}
  | <>                  :: :: noteq      {{tex \neq }}
  | ~                   :: :: match      {{tex = }}
  | ~/~                 :: :: dmatch     {{tex \not= }}
  | @                   :: :: attag    {{tex {\scriptstyle \mathord{@} } }}
  | ;;                  :: :: semisemi   {{tex \mathord{;\!;} }}
  | +                   :: :: plus       {{tex \mathord{+} }}
  | +1                  :: :: plusplus   {{tex {\scriptstyle \mathord{+\!+} } }}
  | |->                 :: :: mapsto     {{tex {\scriptstyle \mathord{\mapsto} } }}
  | forall              :: :: forall     {{tex \forall }}
  | <=                  :: :: le         {{tex \le }}
  | Smty                :: :: Smty       {{tex \text{\sf mty} }}
  | Tbot                :: :: Tbot        {{tex \mathtt{T}_{\bot} }}
  | <|                  :: :: lcp        {{tex \langle }}
  | |>                  :: :: rcp        {{tex \rangle }}

  | Call                :: :: Call      {{tex \text{\sf Call} }} 
  | Output              :: :: Output    {{tex \text{\sf Output} }}
  | Invalid             :: :: Invalid   {{tex \text{\sf Invalid} }}
  | Load                :: :: Load       {{tex \text{\sf Load} }} 
  | Store               :: :: Store      {{tex \text{\sf Store} }} 
  | Nop                 :: :: Nop        {{tex \text{\sf Nop} }}
  | Push                :: :: Push       {{tex \text{\sf Push} }} 
  | Pop                 :: :: Pop        {{tex \text{\sf Pop} }} 
  | Dup                 :: :: Dup        {{tex \text{\sf Dup} }} 
  | BinOp               :: :: BinOp      {{tex \text{\sf BinOp} }}
  | Jump                :: :: Jump       {{tex \text{\sf Jump} }} 
  | BNZ                 :: :: BNZ        {{tex \text{\sf BNZ} }} 
  | Ret                 :: :: Ret        {{tex \text{\sf Ret} }} 
  | Halt                :: :: Halt       {{tex \text{\sf Halt} }} 

  | call                :: :: oCall      {{tex \text{\sf Call} }} 
  | out                 :: :: oOutput    {{tex \text{\sf Output} }}
  | load                :: :: oLoad       {{tex \text{\sf Load} }} 
  | str                 :: :: oStore      {{tex \text{\sf Store} }} 
  | nop                 :: :: oNop        {{tex \text{\sf Nop} }}
  | push                :: :: oPush       {{tex \text{\sf Push} }} 
  | pop                 :: :: oPop        {{tex \text{\sf Pop} }} 
  | dup                 :: :: oDup        {{tex \text{\sf Dup} }} 
  | binop               :: :: oBinOp      {{tex \text{\sf BinOp} }}
  | jump                :: :: oJump       {{tex \text{\sf Jump} }} 
  | bnz                 :: :: oBNZ        {{tex \text{\sf BNZ} }} 
  | ret                 :: :: oRet        {{tex \text{\sf Ret} }} 

  | cepsilon             :: :: eE0       {{tex \varepsilon }} 
  | upriv               :: :: upriv     {{tex \text{\sf u} }} 
  | kpriv               :: :: kpriv      {{tex \text{\sf k} }} 

defns
SmallStepEval :: '' ::=

  defn
  priv1 , C1 , F1 , cM1 , I1 , cS1 , cpc1 -- ce -> priv2 , C2 , F2 , cM2 , I2 , cS2 , cpc2  :: :: step :: '' 
  {{tex \def\arraystretch{.7}
  \setlength\arraycolsep{2pt} \begin{array}{lclrlc}
  [[priv1]] & [[C1]] & [[cM1]] & [[cS1]] & [[cpc1]] & \xrightarrow{[[ce]]} \\
  [[priv2]] & [[C2]] & [[cM2]] & [[cS2]] & [[cpc2]]
  \end{array} }} by

     I(n) = Nop
     C ~ (nop | T | _, _, _ | R, _)         
     ------------------------------------- :: Nop
     upriv, C, F, cM, I, cS, n@T -- cepsilon -> upriv, C, F, cM, I, cS, n+1@R

     I(n) = Nop
     ki ~/~ (nop | T | _, _, _) ~ kj
     ------------------------------------- :: Nop_F
     upriv, [ki,ko], F, cM, I, cS, n@T -- cepsilon -> kpriv, [kj,kbot], F, cM, I, [(n@T, upriv) ;; cS], 0@Tbot

     F(n) = Nop
     ------------------------------------- :: Nop_P
     kpriv, C, F, cM, I, cS, n@T -- cepsilon -> kpriv, C, F, cM, I, cS, n+1@T

     I(n) = Output
     C ~ (out | T | T1, _, _| R1, R2)         
     -------------------------------------------------------- :: Out
     upriv, C, F, cM, I, [m@T1; cS], n@T -- m@R2 -> upriv, C, F, cM, I, cS, n+1@R1

     I(n) = Output
     ki ~/~ (out | T | T1, _, _) ~ kj
     -------------------------------------------------------- :: Out_F
     upriv, [ki,ko], F, cM, I, [m@T1; cS], n@T -- cepsilon -> kpriv, [kj,kbot], F, cM, I, [(n@T,upriv) ;; m@T1 ; cS], 0@Tbot

     I(n) = BinOp o
     C ~ (binop | T | T1, T2, _| R1, R2) 
    -------------------------------------------------------- :: BOp
     upriv, C, F, cM, I, [n1@T1; n2@T2; cS], n@T -- cepsilon -> upriv, C, F, cM, I, [(n1 o n2)@R2; cS], n+1@R1

     I(n) = BinOp o
     ki ~/~ ( binop | T | T1, T2, _) ~ kj
    -------------------------------------------------------- :: BOp_F
     upriv, [ki,ko], F, cM, I, [n1@T1; n1@T2; cS], n@T -- cepsilon -> kpriv, [kj,kbot], F, cM, I, [ (n@T,upriv);; n1@T1; n1@T2 ; cS], 0@Tbot

     F(n) = BinOp o
    -------------------------------------------------------- :: BOp_P
     kpriv, C, F, cM, I, [n1@T1; n1@T2; cS], n@T -- cepsilon -> kpriv, C, F, cM, I, [(n1 o n2)@T; cS], n+1@T
     
     I(n) = Push m
     C ~ ( push | T | _, _, _| R1, R2)
     -------------------------------------------------------- :: Psh
     upriv, C, F, cM, I, cS, n@T -- cepsilon -> upriv, C, F, cM, I, [m @ R2; cS], n+1@R1

     I(n) = Push m
     ki ~/~ ( push | T | _, _, _) ~ kj
     -------------------------------------------------------- :: Psh_F
     upriv, [ki,ko], F, cM, I, cS, n@T -- cepsilon -> kpriv, [kj,kbot], F, cM, I, [(n@T,upriv) ;; cS], 0@Tbot

     F(n) = Push m
     -------------------------------------------------------- :: Psh_P
     kpriv, C, F, cM, I, cS, n@T -- cepsilon -> kpriv, C, F, cM, I, [m @ Tbot; cS], n+1@T

     I(n) = Load
     cread cM p = m@T2
     C ~ ( load | T | T1, T2, _| R1, R2)
     -------------------------------------------------------- :: Ld
     upriv, C, F, cM, I, [p@T1; cS], n@T -- cepsilon -> upriv, C, F, cM, I, [m@R2; cS], n+1@R1

     I(n) = Load
     cread cM p = m@T2
     ki ~/~ ( load | T | T1, T2, _) ~ kj
     -------------------------------------------------------- :: Ld_F
     upriv, [ki,ko], F, cM, I, [p@T1; cS], n@T -- cepsilon -> kpriv, [kj,kbot], F, cM, I, [(n@T,upriv) ;; p@T1; cS], 0@Tbot

     F(n) = Load
     read C p = m@T2
     -------------------------------------------------------- :: Ld_P
     kpriv, C, F, cM, I, [p@T1; cS], n@T -- cepsilon -> kpriv, C, F, cM, I, [m@T2; cS], n+1@T

     I(n) = Store    quad    cread cM p = m@T3
     C ~ ( str | T | T1, T2, T3| R1, R2) 
     cstore cM p (m@R2) = cM'
     -------------------------------------------------------- :: St
     upriv, C, F, cM, I, [p@T1; m@T2; cS], n@T -- cepsilon -> upriv, C, F, cM', I, cS, n+1@R1

     I(n) = Store    quad    cread cM p = m@T3
     ki ~/~ ( str | T | T1, T2, T3)  ~ kj
     -------------------------------------------------------- :: St_F
     upriv, [ki,ko], F, cM, I, [p@T1; m@T2; cS], n@T -- cepsilon -> kpriv, [kj,kbot], F, cM, I, [ (n@T,upriv) ;; p@T1; m@T2; cS], 0@Tbot 

     F(n) = Store    
     store C p (m@T2) = C'
     -------------------------------------------------------- :: St_P
     kpriv, C, F, cM, I, [p@T1; m@T2; cS], n@T -- cepsilon -> kpriv, C', F, cM, I, cS, n+1@T

     I(n) = Jump
     C ~ ( jump | T | T1, _, _| R1, _)
      -------------------------------------------------------- :: Jmp
     upriv, C, F, cM, I, [m@T1; cS], n@T -- cepsilon -> upriv, C, F, cM, I, cS, m@R1

     I(n) = Jump
     ki ~/~ ( jump | T | T1, _, _) ~ kj
      -------------------------------------------------------- :: Jmp_F
     upriv, [ki,ko], F, cM, I, [m@T1; cS], n@T -- cepsilon -> kpriv, [kj,kbot], F, cM, I, [ (n@T,upriv) ;; m@T1 ; cS], 0@Tbot

     F(n) = Jump
      -------------------------------------------------------- :: Jmp_P
     kpriv, C, F, cM, I, [m@T1; cS], n@T -- cepsilon -> kpriv, C, F, cM, I, cS, m@T

     I(n) = BNZ m
     C ~ ( bnz | T | T1, _, _| R1, _)
     n' = n + (l = 0)? 1 : m  
     -------------------------------------------------------- :: Bnz
     upriv, C, F, cM, I, [l@T1; cS], n@T -- cepsilon -> upriv, C, F, cM, I, cS, n'@R1
    
     I(n) = BNZ m
     ki ~/~ ( bnz | T | T1, _, _) ~ kj
     -------------------------------------------------------- :: Bnz_F
     upriv, [ki,ko], F, cM, I, [l@T1; cS], n@T -- cepsilon -> kpriv, [kj,kbot], F, cM, I, [ (n@T,upriv) ;; l@T1 ; cS], 0@Tbot

     F(n) = BNZ m
     n' = n + (l = 0)? 1 : m
     -------------------------------------------------------- :: Bnz_P
     kpriv, C, F, cM, I, [l@T1; cS], n@T -- cepsilon -> kpriv, C, F, cM, I, cS, n'@T

     I(n) = Call
     C ~ ( call | T | T1, _, _| R1, R2)
     -------------------------------------------------------- :: Cll
     upriv, C, F, cM, I, [ p@T1 ; ca ; cS], n@T -- cepsilon -> upriv, C, F, cM, I, [ca; (n+1@R2,upriv) ;; cS], p@R1

     I(n) = Call
     ki ~/~ ( call | T | T1, _, _) ~ kj
     -------------------------------------------------------- :: Cll_F
     upriv, [ki,ko], F, cM, I, [ p@T1 ; ca ; cS], n@T -- cepsilon -> kpriv, [kj,kbot], F, cM, I, [ (n@T,upriv) ;; p@T1 ; ca ; cS], 0@Tbot

     % CH: why not p@T in the result?
     F(n) = Call
     -------------------------------------------------------- :: Cll_P
     kpriv, C, F, cM, I, [ p@T1 ; ca ; cS], n@T -- cepsilon -> kpriv, C, F, cM, I, [ca; (n+1@T,kpriv) ;; cS], p@T1

     I(n) = Ret
     C ~ ( ret | T | T1, T2, _| R1, R2)
     -------------------------------------------------------- :: Ret
     upriv, C, F, cM, I, [m@T1 ; (p@T2,priv) ;; cS], n@T -- cepsilon -> priv, C, F, cM, I, [m@R2 ; cS], p@R1

     I(n) = Ret
     ki ~/~ ( ret | T | T1, T2, _) ~ kj
     -------------------------------------------------------- :: Ret_F
     upriv, [ki,ko], F, cM, I, [l@T1 ; (p@T2,priv) ;; cS], n@T -- cepsilon -> kpriv, [kj,kbot], F, cM, I, [ (n@T,upriv) ;; l@T1 ; (p@T2,priv) ;; cS], 0@Tbot

     F(n) = Ret
     -------------------------------------------------------- :: Ret_P
     kpriv, C, F, cM, I, [(p@T1,priv) ;; cS], n@T -- cepsilon -> priv, C, F, cM, I, cS, p@T1

     % I(pc) = Pop
     % -------------------------------------------------------- :: Pop
     % cM, I, [a; cS], pc -- espilon -> cM, I, cS, pc+1

     % I(pc) = Swap
     % -------------------------------------------------------- :: Swap
     % cM, I, [a1; a2; cS], pc -- espilon -> cM, I, [a2; a1; cS], pc+1

     % I(pc) = Ret
     % -------------------------------------------------------- :: Ret_Pop
     % cM, I, [a; a'; cS], pc --cepsilon -> cM, I, [a; cS], pc

     % cM(pc) = Dup
     % -------------------------------------------------------- :: Dup
     % cM, [a; cS], pc, T --> cM, [a;a;cS], pc+1, T
    


