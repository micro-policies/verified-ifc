\documentclass{scrartcl}

\usepackage{amsmath,amssymb,amsthm}
\usepackage{stmaryrd}
\usepackage{supertabular}
\usepackage{fullpage}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{fancyvrb}

\input{temp/defns}

\renewcommand{\ottkw}[1]{\mathsf{#1}}

\definecolor{dkblue}{rgb}{0,0.1,0.5}
\definecolor{dkgreen}{rgb}{0,0.3,0}
\definecolor{dkred}{rgb}{0.6,0,0}

\newcommand{\comm}[3]{\textcolor{#1}{[#2: #3]}}
\newcommand{\ch}[1]{\comm{violet}{CH}{#1}} % Catalin
\newcommand{\bcp}[1]{\comm{dkred}{BCP}{#1}} % Benjamin
\newcommand{\dd}[1]{\comm{dkblue}{DD}{#1}} % Delphine

\renewcommand{\ottdrulename}[1]{\footnotesize\textsc{#1}}
\renewcommand{\ottdrule}[4][]
           {{\displaystyle\frac{\begin{array}{l}#2\end{array}}{#3}~\ottdrulename{#4}}}

\begin{document}

\section*{Notes}

\begin{itemize}
\item Ott file for the current concrete pico machine with output.
  \begin{itemize}
    \item the user program and tmu fault handler code are implicit,
      and global to the step relation
    \item what about the fault handler code? 
    \item for now, just two rules per instr (success or fault), but
      ultimately, there's also the case of privileged mode.
      that's a lot of rules...
      Perhaps one or two, to show that the concrete machine is 
      using "default-labelled" values (using bot), and is not checking
      anything on them.
    \item notation for fault handler cache: only payload-labels are
      specified and not their labels. these could be any labels actually.
    \item when IFC-faulting, no effect on the memory (see rule for
      Store), and the stack below the frame of the tmu fault handler
      is also unchanged, so that, when returning from it, we can
      "replay" the instruction, with a cache that is up-to-date.
  \end{itemize}
\item Questions:
  \begin{itemize}
    \item Strictly speaking, the rule for Call is returning three
      things: the next pc for callee, the next pc inside the caller,
      and the label to put on the argument passed to the function.
      this ought to be fixed, I would say. For now: just two results.
    \item Output and privileged mode: we can either make it blocking
      (saving one rule), or make it step, but observe that the tmu
      fault handler code do use output instruction. Made it blocking
      for now.
    \item Returning from priv mode to user mode: seems odd/dangerous
      to return a value here... For now, Ret is a value return at the
      abstract level, and a void return in priv mode. Need to
      reintroduce two kinds of return instruction?
  \end{itemize}
\end{itemize}

\section*{Syntax}

\ottmetavars\\[3ex]

\ottgrammartabular{
%% \ottM\ottinterrule
%% \ottframe\ottinterrule
\ottn\ottinterrule
%% \ottp\ottinterrule
%% \ottv\ottinterrule
%% \ottov\ottinterrule
\ottL\ottinterrule
\otta\ottinterrule
\ottinstr\ottinterrule
%% \ottopcode\ottinterrule
\ottS\ottinterrule
}

\section*{Auxiliary relations}

\ottgrammartabular{
\ottformula\ottinterrule
}

\pagebreak
\section*{Step relation}

\small
%% \ottdefnss

%% \begin{ottdefnblock}{$ \ottnt{b_{{\mathrm{1}}}} ,  \kappa_{{\mathrm{1}}} ,  \mu_{{\mathrm{1}}} ,  \sigma_{{\mathrm{1}}} ,  \ottnt{pc_{{\mathrm{1}}}}  \xrightarrow{ \ottnt{e} }  \ottnt{b_{{\mathrm{2}}}} ,  \kappa_{{\mathrm{2}}} ,  \mu_{{\mathrm{2}}} ,  \sigma_{{\mathrm{2}}} ,  \ottnt{pc_{{\mathrm{2}}}} $}{}
%% \end{ottdefnblock}

\[ \ottdruleNop \ottinterrule 
   \quad \ottdruleNopXXF \ottinterrule 
   \quad \ottdruleNopXXPriv \ottinterrule \]
\[ \ottdruleOut \ottinterrule
   \qquad  \ottdruleOutXXF \ottinterrule \]
\[ \ottdruleBinOp \ottinterrule
   \quad \ottdruleBinOpXXF \ottinterrule \]
\[ \ottdrulePush \ottinterrule 
   \quad \ottdrulePushXXF \ottinterrule
   \quad \ottdrulePushXXPriv \ottinterrule \]
 \[ \ottdruleLoad \ottinterrule 
   \quad \ottdruleLoadXXF \ottinterrule
   \quad \ottdruleLoadXXPriv \ottinterrule \]
\[ \ottdruleStore \ottinterrule
   \quad \ottdruleStoreXXF \ottinterrule \]
\[ \ottdruleBinOpXXPriv \ottinterrule
   \quad \ottdruleStoreXXPriv \ottinterrule \]
\[ \ottdruleJmp \ottinterrule
   \quad \ottdruleJmpXXF \ottinterrule 
   \quad \ottdruleJmpXXPriv \ottinterrule \]
\[ \ottdruleBNZ \ottinterrule 
   \quad  \ottdruleBNZXXF \ottinterrule
   \quad  \ottdruleBNZXXPriv \ottinterrule  \] 
\[ \ottdruleCall \ottinterrule
   \quad  \ottdruleCallXXF \ottinterrule \]
\[ \ottdruleRet \ottinterrule   
   \quad  \ottdruleRetXXF \ottinterrule  \] 
\[ \ottdruleCallXXPriv \ottinterrule
   \quad  \ottdruleRetXXPriv \ottinterrule \] 

% \begin{quote}
% \ottgrammartabular{%
%    \ottC\ottinterrule
%    \ottt\ottinterrule
%    \ottu\ottinterrule
%    \ottv\ottinterrule
%    \ottG\ottinterrule
%    \ottbuf\ottinterrule
% }
% \end{quote}

\end{document}

% LocalWords:  canElim canReclassify injective Elim Recl TL BCP TODO
% LocalWords:  canEliminate newprin
